<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>索时</title>
  
  <subtitle>欢迎你的到来</subtitle>
  <link href="http://suojifeng.xyz/atom.xml" rel="self"/>
  
  <link href="http://suojifeng.xyz/"/>
  <updated>2025-08-01T01:25:47.367Z</updated>
  <id>http://suojifeng.xyz/</id>
  
  <author>
    <name>suojifeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++</title>
    <link href="http://suojifeng.xyz/2025/08/01/c/"/>
    <id>http://suojifeng.xyz/2025/08/01/c/</id>
    <published>2025-08-01T01:25:47.000Z</published>
    <updated>2025-08-01T01:25:47.367Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>感悟</title>
    <link href="http://suojifeng.xyz/2025/05/14/gan-wu/"/>
    <id>http://suojifeng.xyz/2025/05/14/gan-wu/</id>
    <published>2025-05-14T07:19:01.000Z</published>
    <updated>2025-05-14T08:07:51.220Z</updated>
    
    <content type="html"><![CDATA[<p>​今天是2025年的5月14日，盲审终于通过了，然后身体检查感觉吃吃药也是可以的，体检应该是没什么问题，还算是一个结果吧。</p><p>​为什么今天想去发博客了，原因在NGA平台上看到了一篇《我的前半生》，想想已经25岁了，远不如刚大学毕业18岁那年的意气风发，感觉到时光过得真快啊，如果要写我的前半生我应该怎么去写呢，看着已经发福的身体，是不是还想着瘦瘦的自己。</p><p>​ 定一个基调吧，那就是遗憾与前进。</p><p>​从小的时候就是在不被看好的情况中出生与长大，大家都瞧不起你，偏偏你也不争气。从小就口吃，早产，自卑，敏感。这是我对我小学生涯的一个总结。因为口吃被同龄人嘲笑，也没有什么很聊得来的朋友，还记得每天放假之后需要母亲辅导我作业，感觉也是笨蛋一个。到了四五年级感觉是老天眷顾还是其他，学习成绩还算不错，不过这个时候也太贪玩了，被堂哥引导去网吧，从没见过电脑的那会受到这种诱惑，从此便开始了偷家里的钱去网吧上网的道路，记得很清楚的就是被家里人抓住之后跪了1个小时，但是家里人基本上没有打过我，到现在也是十分感谢了。小学的印象应该就是唯唯诺诺没本事，自己看到都想给一拳。</p><p>​到了考初中，经典没考好，但是还是做出了决定去了矿区里面上初中。初中的基调应该是混乱与寻找。就像是小村庄里面的学生到了大城市一样，我清楚的记得，第一次考试班里一共60个学生，我应该排在40多名的成绩，长得既矮又黑，属实是没什么优点特长了。好在认识了一些同学，感觉自卑敏感成为了我身上脱不去的长衣一样，过得闷闷不乐。</p><p>​初中正是情窦初开的时候，班里面的情况也比较严重，我自然也是守不住的，自是感觉较为缺爱的一个环节，总是想要找到一个喜欢自己的，在那个时候自然是不可能了，长得不好看，有没有什么优点。喜欢过女生，没有结果也也很正常。最出生的是搞暧昧玩脱了然后还觉得自己没问题的，现在想想自己那个时候真的不把感情当回事，写的太细节又忘的很多。</p><p>​ 先写到这里吧，反正也是自说自话。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​
今天是2025年的5月14日，盲审终于通过了，然后身体检查感觉吃吃药也是可以的，体检应该是没什么问题，还算是一个结果吧。&lt;/p&gt;
&lt;p&gt;​
为什么今天想去发博客了，原因在NGA平台上看到了一篇《我的前半生》，想想已经25岁了，远不如刚大学毕业18岁那年的意气风发，</summary>
      
    
    
    
    
    <category term="daily life" scheme="http://suojifeng.xyz/tags/daily-life/"/>
    
    <category term="CR" scheme="http://suojifeng.xyz/tags/CR/"/>
    
  </entry>
  
  <entry>
    <title>想与梦</title>
    <link href="http://suojifeng.xyz/2025/04/07/xiang-yu-meng/"/>
    <id>http://suojifeng.xyz/2025/04/07/xiang-yu-meng/</id>
    <published>2025-04-07T10:42:35.000Z</published>
    <updated>2025-04-07T10:55:42.989Z</updated>
    
    <content type="html"><![CDATA[<p>好像听说过梦到一个人说明缘分已经断了，好像是这样的，想不起来声音，想不起来模样，但就是知道那个人就是你，真真假假，假假真真，我已不在去想，凭增烦恼罢了，我有意也是空想，世界还是务实一点好。</p><p>写论文太折磨了，改的也很难受，身体还是要注重一下</p><p>如果你看到这这篇博客，说明我还没忘记</p><p>缘分这个东西太过奇妙</p><p>最后一次吗？不好说，难说CR</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好像听说过梦到一个人说明缘分已经断了，好像是这样的，想不起来声音，想不起来模样，但就是知道那个人就是你，真真假假，假假真真，我已不在去想，凭增烦恼罢了，我有意也是空想，世界还是务实一点好。&lt;/p&gt;
&lt;p&gt;写论文太折磨了，改的也很难受，身体还是要注重一下&lt;/p&gt;
&lt;p&gt;如</summary>
      
    
    
    
    
    <category term="daily life" scheme="http://suojifeng.xyz/tags/daily-life/"/>
    
    <category term="CR" scheme="http://suojifeng.xyz/tags/CR/"/>
    
  </entry>
  
  <entry>
    <title>新的旅程</title>
    <link href="http://suojifeng.xyz/2024/12/04/xin-de-lu-cheng/"/>
    <id>http://suojifeng.xyz/2024/12/04/xin-de-lu-cheng/</id>
    <published>2024-12-04T07:13:02.000Z</published>
    <updated>2024-12-09T07:30:45.795Z</updated>
    
    <content type="html"><![CDATA[<p>秋招终于落下帷幕，终于松了一口气，自己做出了算是在人生路途上的重大决定。</p><p>每一个选择都有代价，在做出重大选择的时候都会犹豫是否会把自己的人生推向另外不好的一边，这就是后悔的魔力与代价，但我正是要追寻自己的内心与渴望，可以说我自己做的决定，我认为我走在正确的道路上，当我眺望远方我觉得这是正确的。后悔也只是马后炮，当时难道没有做过选择吗，做过的，这正是权衡利弊之后的决定，还是那句话，人的一生只有一次，做好自己，朝着未来的方向冲吧，抗压是要抗压的，只要未来是光明的美好的。</p><figure><img src="/2024/12/04/xin-de-lu-cheng/索时.jpg" alt="索时"><figcaption aria-hidden="true">索时</figcaption></figure><p>最近听到很有意思的一句话，分享给大家，</p><p>People are always happiest when they are infinitely close tohappiness.</p><p>人总是在接近幸福时倍感幸福，在幸福进行时却患得患失。</p><p>有些人一直没有机会见等有机会了，却又犹豫了，相见不如不见。</p><p>有些事一直没有机会做等，有机会了，却又不想做了。</p><p>有些话一直没有机会说，等有机会了，却又不想说了。</p><p>有些爱一直没有机会爱，等有机会了，却又不爱了。</p><p>见了她他变得很，低到尘埃里，从尘埃里开出花来，但他心里是欢喜的，从尘埃里开出花来，</p><p>我要你知道，在这个世界上，总有一个人是等着你的，不管在什么时候，不管在什么地方，</p><p>反正你知道总有这么一个人，你问我爱你值得不值得。</p><p>其实你应该知道爱就是不问值得不值得笑。</p><p>全世界便于你同笑。哭，你便独自哭，长的是磨难短的是人生。</p><p>在人生的路上，有一条路，每个人都非走不可，那就是年轻的弯路</p><p>有些傻话，不但需要背着人说，还得背着自己让自己听见了也怪难为情的。</p><p>臂如说我爱你，我一辈子都爱你。</p><p>是的啊，无限接近期望幸福的时候是最幸福的，但是当他真正到来了却又身在其中看不清楚，<img src="/2024/12/04/xin-de-lu-cheng/毕业生.png" alt="毕业生"></p><p>对未来迷茫看不清楚，但是期待又还是存在，仅仅存留在想象当中也不是一种保留的思潮</p><p>还是要继续前进，完成毕业之间的工作是目前的重中之重</p><p>焦虑还不去做，做一些能力之外的事情，多加油一些。</p><p>花有重开日，人无再少年。</p><p>也是属于未来的一天不同的轨迹人生呢CR</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;秋招终于落下帷幕，终于松了一口气，自己做出了算是在人生路途上的重大决定。&lt;/p&gt;
&lt;p&gt;每一个选择都有代价，在做出重大选择的时候都会犹豫是否会把自己的人生推向另外不好的一边，这就是后悔的魔力与代价，但我正是要追寻自己的内心与渴望，可以说我自己做的决定，我认为我走在正确的道</summary>
      
    
    
    
    <category term="My Daily Life" scheme="http://suojifeng.xyz/categories/My-Daily-Life/"/>
    
    
    <category term="daily life" scheme="http://suojifeng.xyz/tags/daily-life/"/>
    
    <category term="CR" scheme="http://suojifeng.xyz/tags/CR/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://suojifeng.xyz/2024/09/09/mian-shi/"/>
    <id>http://suojifeng.xyz/2024/09/09/mian-shi/</id>
    <published>2024-09-09T07:02:49.000Z</published>
    <updated>2025-04-07T10:41:25.435Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程和进程的区别">1.线程和进程的区别</h3><p>进程是分配资源的最小单元，进程包括多个线程，线程其实对应的就是cpu的核心</p><p>线程是操作系统调度的最小单位，多个线程可以共享进程的资源</p><h3 id="tcp和udp的区别">2.TCP和UDP的区别</h3><p>1.TCP是需要握手连接的，udp不用直接发送数据包，但是可靠性低</p><p>2.相对来说TCP较为安全一点，需要3次握手4次回收，具有丢包重传，流量控制和拥塞控制，数据按顺序的，因为有序列号和应答号</p><p>3.udP不用去管连接的顺序和是否成功到达，需要会更进一步的优化才行，使用与视频流，在线游戏这种</p><h3 id="网页输入url整个流程">3.网页输入url整个流程</h3><p>网页上输入URl</p><p>首先我们知道 需要对这个url进行解析，我们需要知道这个 url的地址</p><p>首先就是 DNS域名解析，</p><p><strong>首先是去查看本地缓存里面有没有</strong> 没有</p><p>通过不同的根，域名，顶级解析器来获得 其中的IP地址</p><p>获得IP地址之后应该去传输了，然后是建立连接，使用TCP或者UDP,完成之后浏览器发送http的请求给服务器，（请求头，请求url，请求方法）服务器通过controller 进行处理 执行业务，然后返回对应的相应，其中包括一些响应状态码还是起他，</p><p>状态码的<strong>第一个数字表示响应类别</strong>，后面两位数字表示更详细的状态信息。</p><p>首先是 传输头分片加上MAC的地址，一起去寻找目的地</p><p>然后获得资源就是html前端页面进行渲染这样</p><h3 id="java集合类">4.java集合类</h3><p>集合类包括 list arraylist linkedlist</p><h3 id="hashmap">5.HashMap</h3><p>基于哈希表，主要是hashcode（）计算</p><p>之前是 table+ 链表 后面是 +加上红黑树</p><p>首先是检查 容量是否需要扩容， 然后查看table满了没有，然后放到链表里卖弄，满了转成红黑树，红黑树满了，扩建一般是0.75 两倍</p><p>解决哈希冲突，链表寻址法 + 开放地址（都放在一起，然后多计算几次hashcode存储）</p><p>线性探测，二次探测</p><p>再哈希法当发生冲突时，可以对哈希函数的结果进行重新哈希计算，从而找到一个新的索引位置。这种方法一般和开放地址法结合使用。</p><p>扩容 与 重哈希</p><p><strong>一致性哈希</strong>常用于分布式系统中，它将整个哈希空间视为一个环形结构，避免了数据倾斜问题。它将数据均匀分布到多个桶（节点）中，并在哈希冲突时，通过移动顺时针找到下一个节点。</p><h3 id="jvm">6. JVM</h3><h3 id="mysql如何分页分页数据量大会有什么问题如何解决">7.MySQL如何分页;分页数据量大会有什么问题;如何解决</h3><p>LIMIT page_size OFFSET offset_value;</p><p>offset_value = (page_number - 1) * page_size</p><p><strong>分页数据量大可能带来的问题</strong></p><p>当数据量较大时，使用 <code>LIMIT</code> 和 <code>OFFSET</code>进行分页会遇到以下几个问题：</p><h4 id="a.-性能问题">a. <strong>性能问题</strong></h4><ul><li><code>OFFSET</code> 会跳过前面的记录，这意味着 MySQL 需要扫描<code>OFFSET + LIMIT</code> 记录，但实际上只返回 <code>LIMIT</code>条。因此，当 <code>OFFSET</code> 值很大时，MySQL仍需要扫描大量数据，造成查询效率下降。</li><li>随着 <code>OFFSET</code>增加，查询的时间复杂度会逐渐变高，特别是在大表中，响应时间可能显著增加。</li></ul><h4 id="b.-内存消耗">b. <strong>内存消耗</strong></h4><ul><li>MySQL在执行查询时，可能会将查询结果放在内存中，特别是当没有合适的索引时。对于大数据集分页，内存消耗会显著增加，可能会影响系统性能。</li></ul><h3 id="spring设计模式有哪些">8.spring设计模式有哪些</h3><p><strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong></p><h4 id="创建型模式creational-patterns"><strong>创建型模式（CreationalPatterns）</strong></h4><p>创建型模式关注对象的创建过程，解决对象创建的复杂性，提供更灵活的对象创建方式。</p><ol type="1"><li><p><strong>工厂方法模式（Factory Method）</strong></p><ul><li>定义：通过定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让类的实例化延迟到子类。</li><li>场景：当类不知道它所需要创建的对象的确切类型时。</li><li>例子：<code>LoggerFactory</code>根据日志类型创建不同的日志对象。</li></ul><p>在spring中 <code>BeanFactory</code> 和<code>ApplicationContext</code> 是典型的工厂模式的实现。用于创建和管理Spring Bean 实例，控制对象的创建过程，使得对象的创建与使用分离。</p><pre class="line-numbers language-none"><code class="language-none">ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");MyBean myBean = context.getBean(MyBean.class);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>抽象工厂模式（Abstract Factory）</strong></p><ul><li><p>定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p>场景：当系统需要独立于对象的具体实现来创建多个相关对象时。</p></li><li><p>例子：创建不同品牌的家具（如椅子、桌子等），具体品牌由工厂类决定。</p><p>在 Spring 中，<code>BeanFactory</code>是一个抽象工厂，负责提供一个或多个工厂接口来创建 Bean 实例。</p></li></ul></li><li><p><strong>单例模式（Singleton）</strong></p><ul><li><p>定义：确保某个类只有一个实例，并提供一个全局访问点来访问该实例。</p></li><li><p>场景：需要确保全局有且只有一个实例时，如数据库连接、日志管理器等。</p></li><li><p>例子：<code>DatabaseConnection</code>，所有访问数据库的操作共享同一个连接实例。</p><p>Spring 默认情况下 Bean 是单例的（通过<code>@Scope("singleton")</code> 声明），这意味着每个 Spring容器中只有一个实例。保证在整个应用程序中，某个类的实例只有一个，减少内存占用，避免频繁创建和销毁对象。Spring中每个默认 <code>Bean</code> 实例都是单例，生命周期由容器控制。</p></li></ul></li><li><p><strong>原型模式（Prototype）</strong></p><ul><li>定义：通过复制现有实例来创建新对象，而不是通过类实例化。</li><li>场景：当需要创建的对象是相似或重复时，避免昂贵的对象创建过程。</li><li>例子：克隆一份复杂对象，如深度复制具有复杂结构的对象。</li></ul></li><li><p><strong>建造者模式（Builder）</strong></p><ul><li>定义：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li><li>场景：需要构建复杂对象时，尤其是这些对象由多个部分组成，并且构建过程可按步骤进行。</li><li>例子：构建一个具有多种配置的房屋，建造者类按步骤创建房屋的不同部分。</li></ul></li></ol><h4 id="结构型模式">结构型模式</h4><p>结构型模式关注类与对象的组合，简化类的设计和对象之间的关系。</p><p><strong>适配器模式（Adapter）</strong></p><ul><li><p>定义：将一个类的接口转换成客户希望的另一个接口。适配器使得原本由于接口不兼容而不能一起工作的类可以一起工作。</p></li><li><p>场景：当现有的类接口与需要的接口不匹配时。</p></li><li><p>例子：电源适配器，将不同的电压接口转换成设备所需的电压。</p><p>Spring MVC 中的 <code>HandlerAdapter</code>使用了适配器模式，使不同的 <code>Controller</code>能够通过统一的接口进行调用。</p><p>适配器将不同类型的处理器（如<code>Controller</code>、<code>HttpRequestHandler</code>）适配到统一的<code>HandlerAdapter</code> 接口，简化了调用过程。</p></li></ul><p><strong>装饰者模式（Decorator）</strong></p><ul><li>定义：动态地给一个对象添加一些额外的职责。装饰者模式提供了比继承更有弹性的扩展功能的方式。</li><li>场景：需要在不修改原有类的情况下，给对象动态地添加功能。</li><li>例子：Java IO 流中的 <code>BufferedReader</code> 和<code>InputStream</code>，可以动态添加缓冲或其他功能。</li></ul><p><strong>代理模式（Proxy）</strong></p><ul><li><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p></li><li><p>场景：需要控制对象的访问、延迟加载、权限控制等。</p></li><li><p>例子：远程代理（调用远程对象时，使用本地代理对象来代表它）。</p><p>SpringAOP（面向切面编程）大量使用了代理模式来对目标对象进行增强，常见的动态代理实现包括JDK 动态代理和 CGLIB 代理。</p><p>在不修改目标对象的情况下，通过代理对象添加额外的功能，例如日志记录、事务管理、权限检查等。</p><pre class="line-numbers language-none"><code class="language-none">@Transactionalpublic void someMethod() {    // 事务处理代码由代理对象注入}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="结构型模式-1">结构型模式</h4><p><strong>策略模式（Strategy）</strong></p><ul><li>定义：定义一系列算法，将每个算法封装起来，使得它们可以互换使用。</li><li>场景：需要在运行时动态选择算法时。</li><li>例子：支付系统中，可以选择不同的支付方式（如信用卡、PayPal、银行转账等）。</li></ul><p><strong>观察者模式（Observer）</strong></p><ul><li>定义：定义对象间的一对多依赖，当一个对象的状态发生改变时，所有依赖于它的对象都能自动收到通知。</li><li>场景：对象状态变化时，自动通知所有依赖对象。</li><li>例子：GUI 中的按钮和点击事件，订阅者和发布者模式。</li></ul><h3 id="单例模式的实现">9.单例模式的实现</h3><pre class="line-numbers language-none"><code class="language-none">1.双重延迟public class Singleton {    private volatile static Singleton instance;    private Singleton(){}    public static  Singleton getInstance(){        if(instance == null){            synchronized (Singleton.class){                if(instance == null){                    instance = new Singleton();                }            }        }        return instance;    }}2.懒汉式public class Singleton {    private static Singleton instance;    private Singleton(){}    public  static  Singleton getInstance(){        if(instance == null){            instance = new Singleton();            }        return instance;    }}3.延迟加锁public class Singleton {    private static Singleton instance;    private Singleton(){}    public  synchronized static  Singleton getInstance(){        if(instance == null){            instance = new Singleton();            }        return instance;    }}4.饿汉式public class Singleton {    private static  final  Singleton instance = new Singleton();    private Singleton(){}    public  static  Singleton getInstance(){        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="selectpoll和epoll的区别">10.select、poll和epoll的区别</h3><p><code>select</code>、<code>poll</code> 和 <code>epoll</code>都是用于处理多路复用 I/O 的系统调用，它们允许一个线程同时监听多个 I/O操作，但它们的实现方式和性能特性有所不同。以下是它们的主要区别</p><p><strong><code>select</code></strong>：早期的 I/O多路复用机制，适用于少量文件描述符，但在处理大量连接时性能较差。</p><p><strong><code>poll</code></strong>：改进了 <code>select</code>的文件描述符限制问题，适用于中等规模的连接，但性能依然受限于需要遍历所有文件描述符。</p><p><strong><code>epoll</code></strong>：高效的 I/O多路复用机制，适用于大规模并发连接，提供更高的性能，但仅在 Linux上可用。</p><p><code>select</code> 使用一个集合（通常是一个<code>fd_set</code>）来跟踪要监视的文件描述符，<code>select</code>会阻塞直到至少一个文件描述符变得可读、可写或发生异常，或者超时。</p><p><code>poll</code>使用一个数组来保存需要监控的文件描述符及其事件，遍历数组，步限制文件描述符的数量</p><p><code>epoll</code>使用事件通知机制，内核维护一个事件表，并仅将有事件的文件描述符返回给应用程序。</p><h3 id="链表的形式和-应用场景">11.链表的形式和 应用场景</h3><p>链表是一种基本的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。根据不同的实现方式，链表有几种不同的类型，每种类型适用于不同的使用场景：</p><ol type="1"><li><strong>单链表（Singly Linked List）</strong><ul><li><strong>结构</strong>：每个节点包含数据和指向下一个节点的指针。</li><li><strong>优点</strong>：简单，插入和删除操作较为高效（在已知节点的情况下）。</li><li><strong>缺点</strong>：只能从头到尾单向遍历。</li><li><strong>使用场景</strong>：适用于不需要频繁反向遍历的场景，比如实现简单的数据结构（如栈和队列）。</li></ul></li><li><strong>双链表（Doubly Linked List）</strong><ul><li><strong>结构</strong>：每个节点包含数据、指向下一个节点的指针和指向前一个节点的指针。</li><li><strong>优点</strong>：可以在双向上遍历，插入和删除操作比单链表更灵活。</li><li><strong>缺点</strong>：每个节点需要额外的存储空间来保存指向前一个节点的指针。</li><li><strong>使用场景</strong>：需要双向遍历的应用，如实现双向队列（Deque）、浏览器历史记录的回溯。</li></ul></li><li><strong>循环链表（Circular Linked List）</strong><ul><li><strong>结构</strong>：在循环链表中，最后一个节点的指针指向头节点，形成一个闭环。</li><li><strong>优点</strong>：能够从任意节点开始循环遍历整个链表。</li><li><strong>缺点</strong>：需要处理循环的结束情况，可能会导致无限循环。</li><li><strong>使用场景</strong>：适用于需要循环访问链表的场景，如圆形缓冲区（环形队列）和调度算法（如RoundRobin）。</li></ul></li><li><strong>双向循环链表（Doubly Circular Linked List）</strong><ul><li><strong>结构</strong>：结合了双链表和循环链表的特性，节点既有前向和后向指针，也形成一个闭环。</li><li><strong>优点</strong>：支持双向遍历并形成循环结构。</li><li><strong>缺点</strong>：实现相对复杂，需要管理两个指针的循环。</li><li><strong>使用场景</strong>：需要双向遍历和循环访问的场景，如在应用程序中实现菜单或任务调度系统。</li></ul></li><li><strong>跳表（Skip List）</strong><ul><li><strong>结构</strong>：在链表的基础上增加了多个层次的链表来跳过部分节点，从而提高查找效率。</li><li><strong>优点</strong>：在平均情况下查找、插入和删除操作时间复杂度为O(log n)。</li><li><strong>缺点</strong>：比普通链表复杂，需额外的空间来存储多个层次的链表。</li><li><strong>使用场景</strong>：需要高效查找和插入操作的场景，如实现有序集合和数据库索引。</li></ul></li></ol><p>不同类型的链表在实际应用中根据需求的不同，提供了不同的性能特性和灵活性。选择合适的链表类型可以帮助提高程序的效率和可维护性。</p><h3 id="什么是零拷贝netty中的零拷贝">12.什么是零拷贝，netty中的零拷贝</h3><p>零拷贝（Zero-Copy）是一种优化技术，旨在<strong>减少数据在用户空间和内核空间之间的复制操作</strong>，从而提高数据传输的效率。零拷贝主要用于文件传输、网络通信等场景，可以显著减少CPU 的负载和提高 I/O 性能。</p><p>传统的数据传输流程通常包括以下步骤：</p><ol type="1"><li><strong>从文件读取数据</strong>：操作系统将数据从磁盘读入内核空间的缓冲区。</li><li><strong>用户空间的复制</strong>：操作系统将数据从内核缓冲区复制到用户空间的缓冲区。</li><li><strong>网络传输</strong>：将用户空间的缓冲区数据通过网络发送到另一端。</li></ol><p>这种过程会涉及到多次内存复制，导致性能瓶颈。零拷贝技术的目标是减少或消除这些不必要的内存复制操作。</p><p>0copy实现</p><ol type="1"><li><strong><code>mmap</code>（内存映射文件）</strong>：<ul><li>使用 <code>mmap</code>系统调用将文件映射到进程的虚拟内存空间中。这样，文件数据直接存在于内存中，无需将数据从文件系统复制到用户空间缓冲区。</li><li>通过直接访问映射的内存区域，可以避免文件 I/O操作中不必要的内存复制。</li></ul></li><li><strong><code>sendfile</code></strong>：<ul><li><code>sendfile</code>系统调用允许操作系统将文件数据直接从文件描述符发送到网络套接字，而不需要将数据复制到用户空间缓冲区。</li><li>这样可以减少内存复制和 CPU 的消耗，提高数据传输的效率。</li></ul></li><li><strong><code>splice</code></strong>：<ul><li><code>splice</code>系统调用可以在两个文件描述符之间直接移动数据，避免了数据复制到用户空间。</li><li>例如，它可以在文件描述符和套接字之间直接传输数据，适用于处理大型文件的情况。</li></ul></li></ol><h3 id="netty-的零拷贝">Netty 的零拷贝</h3><p>Netty是一个高性能的网络通信框架，它在内部使用了多种零拷贝技术来提高网络传输的效率。</p><h4 id="netty-中的零拷贝实现">Netty 中的零拷贝实现</h4><ol type="1"><li><strong><code>ByteBuf</code></strong>：<ul><li>Netty 使用 <code>ByteBuf</code> 类来处理缓冲区。<code>ByteBuf</code>支持直接缓冲区（<code>DirectByteBuf</code>）和堆内存缓冲区（<code>HeapByteBuf</code>），并提供高效的读取和写入操作。</li><li>直接缓冲区使用了<code>ByteBuffer.allocateDirect()</code>，避免了在用户空间和内核空间之间的数据复制。</li></ul></li><li><strong><code>FileRegion</code></strong>：<ul><li>Netty 提供了 <code>FileRegion</code>接口，可以将文件的数据区域直接传输到网络套接字，而不需要将数据复制到用户空间。</li><li><code>FileRegion</code> 使用了操作系统的 <code>sendfile</code>系统调用来实现零拷贝。</li></ul></li><li><strong><code>Splice</code></strong>：<ul><li>在 Linux 上，Netty 支持使用 <code>splice</code>系统调用来将数据从一个文件描述符传输到另一个文件描述符，而无需数据复制到用户空间。</li><li>这对于在文件系统和网络之间高效地传输数据非常有用。</li></ul></li><li><strong><code>ByteBuffer</code></strong>：<ul><li>Netty 使用 Java NIO 的 <code>ByteBuffer</code>来处理缓冲区。<code>ByteBuffer</code>可以是直接缓冲区（<code>ByteBuffer.allocateDirect()</code>）或堆缓冲区（<code>ByteBuffer.allocate()</code>）。</li><li>直接缓冲区的使用减少了从用户空间到内核空间的数据复制，提高了 I/O性能。</li></ul></li></ol><h3 id="总结">总结</h3><p>零拷贝技术通过减少数据在用户空间和内核空间之间的复制，显著提高了数据传输效率。在Netty 中，通过使用<code>ByteBuf</code>、<code>FileRegion</code>、<code>splice</code> 和<code>ByteBuffer</code>等技术，充分利用了零拷贝的优势，提供了高效的网络通信能力。这些技术使得Netty 在处理大规模网络数据传输时表现出色，能够有效地减少 CPU的负载并提高 I/O 性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程和进程的区别&quot;&gt;1.线程和进程的区别&lt;/h3&gt;
&lt;p&gt;进程是分配资源的最小单元，进程包括多个线程，线程其实对应的就是cpu的核心&lt;/p&gt;
&lt;p&gt;线程是操作系统调度的最小单位，多个线程可以共享进程的资源&lt;/p&gt;
&lt;h3 id=&quot;tcp和udp的区别&quot;&gt;2.</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>spring boot admin</title>
    <link href="http://suojifeng.xyz/2024/09/09/spring-boot-admin/"/>
    <id>http://suojifeng.xyz/2024/09/09/spring-boot-admin/</id>
    <published>2024-09-09T03:01:09.000Z</published>
    <updated>2025-04-07T10:41:18.681Z</updated>
    
    <content type="html"><![CDATA[<p>开源软件Spring Boot Admin</p><p>使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息</p><h2 id="一什么是spring-boot-admin">一、什么是Spring Boot Admin</h2><p>Spring Boot Admin是一个管理和监控SpringBoot应用程序的开源项目，在对单一应用服务监控的同时也提供了集群监控方案，支持通过eureka、consul、zookeeper等注册中心的方式实现多服务监控与管理。SpringBoot Admin UI部分使用Vue JS将数据展示在前端。</p><p>Spring BootAdmin分为服务端（spring-boot-admin-server）和客户端（spring-boot-admin-client）两个组件：</p><ul><li>spring-boot-admin-server通过采集actuator端点数据显示在spring-boot-admin-ui上，已知的端点几乎都有进行采集。</li><li>spring-boot-admin-client是对Actuator的封装，提供应用系统的性能监控数据。此外，还可以通过spring-boot-admin动态切换日志级别、导出日志、导出heapdump、监控各项性能指标等。</li></ul><p>Spring BootAdmin服务器端负责收集各个客户的数据。各台客户端配置服务器地址，启动后注册到服务器。服务器不停地请求客户端的信息（通过Actuator接口）。具体架构如下图所示。</p><p>登录需要 从redis里面存取数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开源软件Spring Boot Admin&lt;/p&gt;
&lt;p&gt;使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息&lt;/p&gt;
&lt;h2 id=&quot;一什么是spring-boot-admin&quot;&gt;一、什么是Spring Boot Admin&lt;/h2&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>sql优化</title>
    <link href="http://suojifeng.xyz/2024/08/22/sql-you-hua/"/>
    <id>http://suojifeng.xyz/2024/08/22/sql-you-hua/</id>
    <published>2024-08-22T09:12:50.000Z</published>
    <updated>2025-04-07T10:41:11.207Z</updated>
    
    <content type="html"><![CDATA[<p>1.加索引</p><p><strong>创建合适的索引</strong>：为查询频繁使用的字段创建索引，例如主键索引、唯一索引和组合索引，减少全表扫描的发生。</p><p><strong>覆盖索引</strong>：通过覆盖索引（即查询所需的所有列都包含在索引中）来避免回表操作，从而加快查询速度。</p><p>2.避免返回不必要的数据列，减少返回的数据列可以增加查询的效率</p><p>3.根据查询分析器适当优什5HL的结构，比如是否走全表扫描、避无子查询等</p><p>4.分库分表</p><p><strong>水平分区（Sharding）</strong>：将大表按某个维度（如日期、ID等）拆分为多个子表，以减少单表数据量，分散查询压力。</p><p><strong>垂直分区</strong>：将表按列进行拆分，特别是将经常一起查询的列放在一个表中，减少单次查询涉及的列数和数据量。</p><p>5.读写分离</p><p>6.语句优化</p><p>避免sql语句和分页查询优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.加索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建合适的索引&lt;/strong&gt;：为查询频繁使用的字段创建索引，例如主键索引、唯一索引和组合索引，减少全表扫描的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;覆盖索引&lt;/strong&gt;：通过覆盖索引（即查询所需的所有列都包含在索引中）来</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>spring</title>
    <link href="http://suojifeng.xyz/2024/08/21/spring/"/>
    <id>http://suojifeng.xyz/2024/08/21/spring/</id>
    <published>2024-08-21T03:16:33.000Z</published>
    <updated>2025-04-07T10:40:59.449Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>锁面试</title>
    <link href="http://suojifeng.xyz/2024/08/21/suo-1/"/>
    <id>http://suojifeng.xyz/2024/08/21/suo-1/</id>
    <published>2024-08-21T02:29:02.000Z</published>
    <updated>2024-08-22T09:30:13.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cas">1.CAS</h2><p>CAS（Compare-And-Swap，比较与交换）是一种常见的无锁（lock-free）机制，用于实现多线程环境下的原子操作。CAS操作通过硬件支持的原子指令来实现，确保在多线程竞争的情况下，数据的一致性和操作的原子性。</p><p>CAS操作涉及三个参数：</p><ul><li><strong>V</strong>：需要更新的变量的内存地址。</li><li><strong>E</strong>：预期值，即当前线程认为变量的值应该是什么。</li><li><strong>N</strong>：新值，即希望将变量更新为的值。</li></ul><p>CAS的执行步骤如下：</p><ol type="1"><li><strong>读取变量V的当前值</strong>。</li><li>比较V的当前值与预期值E：<ul><li>如果相等，说明没有其他线程修改过V，则将变量的值更新为N，并返回<code>true</code>，表示更新成功。</li><li>如果不相等，说明在此期间V已经被其他线程修改，则更新失败，返回<code>false</code>。</li></ul></li></ol><p>这个过程是由硬件指令（如x86架构中的<code>CMPXCHG</code>指令）保证的原子操作，避免了竞态条件（RaceCondition）。</p><p>boolean isUpdated = atomicInteger.compareAndSet(expectedValue,newValue);</p><h3 id="cas的缺点"><strong>CAS的缺点</strong></h3><ul><li><strong>ABA问题</strong>：在CAS操作中，如果一个变量的值从A变为B，再变回A，CAS检查时可能认为值没有变化，从而导致误判。为了解决这个问题，Java引入了<code>AtomicStampedReference</code>，它在CAS操作中加入了版本号（或时间戳），从而检测值的变化。</li><li><strong>自旋问题</strong>：CAS操作失败时通常会不断重试（自旋），这可能导致CPU资源的浪费，尤其是在高竞争的场景下。</li><li><strong>只能保证一个变量的原子性</strong>：CAS只能保证一个共享变量的原子性，如果需要同时操作多个变量，必须使用其他机制如锁或通过组合使用<code>AtomicReference</code>来实现。</li></ul><h2 id="哪些类用到了cas">哪些类用到了CAS</h2><h3 id="atomic系列类">1. <strong><code>Atomic</code>系列类</strong></h3><p>这些类都是在<code>java.util.concurrent.atomic</code>包中，使用CAS实现了原子操作。</p><ul><li><strong><code>AtomicInteger</code></strong>:通过CAS实现了整数值的原子更新操作，如<code>incrementAndGet()</code>、<code>compareAndSet()</code>等。</li><li><strong><code>AtomicLong</code></strong>:与<code>AtomicInteger</code>类似，但操作的是<code>long</code>类型的值。</li><li><strong><code>AtomicBoolean</code></strong>:通过CAS操作<code>boolean</code>类型的值。</li></ul><h3 id="concurrent集合类">2.<strong><code>Concurrent</code>集合类</strong></h3><p>这些类在其实现中使用了CAS来保证多线程环境下的安全和性能。</p><ul><li><strong><code>ConcurrentHashMap&lt;K,V&gt;</code></strong>:通过CAS来实现节点的插入、更新和删除操作，确保在高并发下的线程安全性。</li><li><strong><code>ConcurrentLinkedQueue&lt;E&gt;</code></strong>:使用CAS来实现无锁的队列操作，提供高效的并发队列。</li><li><strong><code>ConcurrentLinkedDeque&lt;E&gt;</code></strong>:类似于<code>ConcurrentLinkedQueue</code>，但支持双端操作。</li><li><strong><code>ConcurrentSkipListMap&lt;K,V&gt;</code></strong> 和<strong><code>ConcurrentSkipListSet&lt;E&gt;</code></strong>:这些类通过CAS实现了跳表（Skip List）的无锁并发操作。</li></ul><h3 id="locks和synchronizers类">3.<strong><code>Locks</code>和<code>Synchronizers</code>类</strong></h3><p>这些类使用CAS来实现高效的线程控制机制。</p><ul><li><strong><code>ReentrantLock</code></strong>:使用CAS来控制锁的状态（如获取锁和释放锁）。</li><li><strong><code>StampedLock</code></strong>:结合了悲观和乐观锁的特性，使用CAS来处理不同模式下的锁定。</li><li><strong><code>CountDownLatch</code></strong>:使用CAS实现计数器的递减操作，保证线程之间的同步。</li><li><strong><code>Semaphore</code></strong>:在信号量计数的增减操作中使用CAS，确保多线程环境下的安全。</li><li><strong><code>Exchanger&lt;V&gt;</code></strong>:使用CAS来实现两个线程之间的数据交换操作。</li><li><strong><code>CyclicBarrier</code></strong>:使用CAS控制线程到达屏障的数量，确保线程安全。</li><li><strong><code>Phaser</code></strong>:使用CAS实现阶段的推进和参与线程的注册/注销。</li></ul><h3 id="threadpoolexecutor">4.<strong><code>ThreadPoolExecutor</code></strong></h3><ul><li>在<code>ThreadPoolExecutor</code>中，CAS用于控制线程池中的工作线程数量、任务的提交和执行状态</li></ul><h2 id="unsafe类">UNSAFE类</h2><p>提供了一组直接操作<strong>内存、线程、类加载等底层操作的方法</strong>。由于它能够绕过Java虚拟机（JVM）的大多数安全检查，因此称为“unsafe”（不安全）。<code>Unsafe</code>类主要用于JVM和核心库的内部实现，在Java应用程序中直接使用它是非常危险的。</p><p>虽然<code>Unsafe</code>类是内部使用的类，但它提供了底层的CAS操作API，许多并发类在其内部实现中都直接使用了<code>Unsafe</code>类的CAS方法，如<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>和<code>compareAndSwapObject</code>。</p><p><strong>底层操作能力</strong>：<code>Unsafe</code>类提供了访问和操作底层内存、对象以及线程的能力，包括直接操作内存、CAS（Compare-And-Swap）操作、对象字段偏移量获取、类实例化等。</p><h3 id="unsafe类的主要功能"><strong><code>Unsafe</code>类的主要功能</strong></h3><ul><li><strong>内存操作</strong>：<ul><li><code>allocateMemory(long bytes)</code>：分配一块指定大小的内存，类似于C语言中的<code>malloc</code>。</li><li><code>freeMemory(long address)</code>：释放通过<code>allocateMemory</code>分配的内存。</li><li><code>putLong(long address, long value)</code>和<code>getLong(long address)</code>：直接在指定内存地址上读写数据。</li></ul></li><li><strong>CAS操作</strong>：<ul><li><code>compareAndSwapInt(Object obj, long offset, int expect, int update)</code>：对指定对象的字段进行CAS操作。</li><li><code>compareAndSwapLong(Object obj, long offset, long expect, long update)</code>：对<code>long</code>类型字段进行CAS操作。</li><li><code>compareAndSwapObject(Object obj, long offset, Object expect, Object update)</code>：对引用类型字段进行CAS操作。</li></ul></li><li><strong>对象操作</strong>：<ul><li><code>getObject(Object obj, long offset)</code>和<code>putObject(Object obj, long offset, Object value)</code>：直接读取和写入对象的字段。</li><li><code>getInt(Object obj, long offset)</code>和<code>putInt(Object obj, long offset, int value)</code>：读取和写入整数字段。</li><li><code>objectFieldOffset(Field field)</code>：获取对象字段在内存中的偏移量，用于直接访问对象字段。</li></ul></li><li><strong>线程操作</strong>：<ul><li><code>park(boolean isAbsolute, long time)</code>：挂起当前线程，类似于<code>LockSupport.park</code>。</li><li><code>unpark(Thread thread)</code>：唤醒指定线程，类似于<code>LockSupport.unpark</code>。</li></ul></li><li><strong>类操作</strong>：<ul><li><code>defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain domain)</code>：在运行时动态定义类。</li><li><code>ensureClassInitialized(Class&lt;?&gt; c)</code>：确保指定类已初始化。</li></ul></li></ul><h3 id="unsafe类的使用场景">3.<strong><code>Unsafe</code>类的使用场景</strong></h3><p>尽管<code>Unsafe</code>类不推荐在应用程序中直接使用，但它在以下场景中非常有用：</p><ul><li><strong>JVM内部实现</strong>：许多JVM内部操作依赖<code>Unsafe</code>类实现，例如直接内存分配、对象实例化等。</li><li><strong>高性能并发库</strong>：<code>java.util.concurrent</code>包中的许多类（如<code>AtomicInteger</code>,<code>ConcurrentHashMap</code>）使用<code>Unsafe</code>类来实现无锁的并发操作，特别是CAS操作。</li><li><strong>性能优化</strong>：在极少数情况下，某些库或框架可能使用<code>Unsafe</code>类来进行性能优化，例如绕过对象创建时的初始化步骤。</li></ul><h2 id="java的锁有哪些">Java的锁有哪些</h2><h3 id="内置锁synchronized"><strong>内置锁（Synchronized）</strong></h3><p>Java内置的锁是最简单和最常用的锁机制，它是语言级的锁，使用<code>synchronized</code>关键字来实现。</p><p>在Java中，<code>synchronized</code>关键字用于同步代码块或方法，以确保在多线程环境中对共享资源的访问是线程安全的。根据<code>synchronized</code>关键字的使用位置，它的作用范围会有所不同，具体表现为加在方法上和加在类上的区别如下：</p><h3 id="synchronized加在实例方法上">1.<strong><code>synchronized</code>加在实例方法上</strong></h3><pre class="line-numbers language-none"><code class="language-none">javaCopy codepublic synchronized void instanceMethod() {    // 同步代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>作用范围</strong>：当<code>synchronized</code>加在实例方法上时，锁定的是当前实例对象（即<code>this</code>）。</li><li><strong>线程独占性</strong>：只有获取了当前实例对象锁的线程才能执行该方法。其他线程如果调用同一个实例的这个<code>synchronized</code>方法或其他<code>synchronized</code>实例方法，都需要等待锁的释放。</li><li><strong>适用场景</strong>：适用于同步控制与特定实例相关的操作，多个实例之间不会互相影响。</li></ul><h3 id="synchronized加在类方法静态方法上">2.<strong><code>synchronized</code>加在类方法（静态方法）上</strong></h3><pre class="line-numbers language-none"><code class="language-none">javaCopy codepublic static synchronized void staticMethod() {    // 同步代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>作用范围</strong>：当<code>synchronized</code>加在静态方法上时，锁定的是当前类的<code>Class</code>对象（即<code>ClassName.class</code>）。</li><li><strong>线程独占性</strong>：只有获取了当前类<code>Class</code>对象锁的线程才能执行该静态方法。其他线程如果调用同一个类的这个<code>synchronized</code>静态方法或其他<code>synchronized</code>静态方法，都需要等待锁的释放。</li><li><strong>适用场景</strong>：适用于同步控制与类本身相关的操作（如访问或修改静态变量），无论创建了多少实例，静态方法的锁都是类级别的，所有线程共享。</li></ul><h3 id="synchronized加在代码块上">3.<strong><code>synchronized</code>加在代码块上</strong></h3><p>除了方法级的锁定，<code>synchronized</code>还可以加在代码块上，以锁定特定对象或类：</p><ul><li><p><strong>锁定实例对象</strong>：</p><pre class="line-numbers language-none"><code class="language-none">javaCopy codepublic void method() {    synchronized(this) {        // 同步代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作用同<code>synchronized</code>实例方法，锁定当前实例对象。</p></li><li><p><strong>锁定类对象</strong>：</p><pre class="line-numbers language-none"><code class="language-none">javaCopy codepublic void method() {    synchronized(ClassName.class) {        // 同步代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作用同<code>synchronized</code>静态方法，锁定当前类对象。</p></li></ul><h3 id="区别总结"><strong>区别总结</strong></h3><ul><li><strong>同步范围</strong>：<code>synchronized</code>加在实例方法上时，锁定范围是实例对象级别，针对单个实例进行同步控制；加在类方法上时，锁定范围是类对象级别，针对整个类进行同步控制。</li><li><strong>影响范围</strong>：实例方法的<code>synchronized</code>只影响同一个实例的其他<code>synchronized</code>实例方法；而类方法的<code>synchronized</code>会影响该类的所有实例对象和该类的其他<code>synchronized</code>静态方法。</li><li><strong>使用场景</strong>：如果需要保护与实例相关的数据，应使用<code>synchronized</code>实例方法；如果需要保护与类相关的静态数据或资源，应使用<code>synchronized</code>静态方法。</li></ul><p>锁优化：</p><h3 id="jvm对synchronized的优化">JVM对<code>synchronized</code>的优化</h3><ol type="1"><li><strong>偏向锁（Biased Locking）</strong><ul><li><strong>原理</strong>：当一个线程首次获取锁时，JVM会偏向于该线程，并将锁标记为偏向锁。之后，如果同一线程再次请求这个锁，JVM不需要执行锁竞争操作，而是直接授予锁。偏向锁在无竞争场景下极大地减少了加锁的开销。</li><li><strong>适用场景</strong>：适用于锁竞争少、同一线程多次进入同步代码块的场景。</li></ul></li><li><strong>轻量级锁（Lightweight Locking）</strong><ul><li><strong>原理</strong>：在锁没有被其他线程竞争的情况下，JVM会将锁从偏向锁升级为轻量级锁。此时，线程通过CAS（Compare-And-Swap）操作来获取锁，而不是传统的阻塞方式。</li><li><strong>适用场景</strong>：适用于短时间内可能出现锁竞争，但竞争不激烈的场景。</li></ul></li><li><strong>自旋锁（Spin Locking）</strong><ul><li><strong>原理</strong>：自旋锁避免了线程在锁竞争失败后立即阻塞，而是让线程短时间内不断地尝试获取锁。这种方式适用于锁竞争时间短的场景，因为线程不会立即进入阻塞态，而是不断尝试获取锁，从而避免了上下文切换的开销。</li><li><strong>适用场景</strong>：适用于锁竞争频繁但每次竞争时间较短的场景。</li></ul></li><li><strong>锁消除（Lock Elimination）</strong><ul><li><strong>原理</strong>：在编译期间，JVM可以通过逃逸分析（EscapeAnalysis）检测到某些锁只在单线程环境中使用，或者锁对象没有逃逸到其他线程，那么JVM会自动消除这些锁。</li><li><strong>适用场景</strong>：适用于单线程场景或锁对象未共享的场景。</li></ul></li><li><strong>锁粗化（Lock Coarsening）</strong><ul><li><strong>原理</strong>：如果JVM检测到在一个方法或代码块中多次使用相同的锁，而这些加锁操作是紧密相连的，那么JVM会将这些锁操作合并为一个更大的锁块，从而减少加锁和解锁的频率。</li><li><strong>适用场景</strong>：适用于频繁的、短时间的锁操作。</li></ul></li><li><strong>适应性自旋（Adaptive Spinning）</strong><ul><li><strong>原理</strong>：在自旋锁的基础上，JVM会根据前一次自旋的结果动态调整自旋的次数。如果自旋能够快速获取锁，则增加自旋次数；反之，则减少自旋次数或直接阻塞线程。</li><li><strong>适用场景</strong>：适用于锁竞争时间波动较大的场景。</li></ul></li></ol><h3 id="开发者对synchronized的优化">开发者对<code>synchronized</code>的优化</h3><ol type="1"><li><strong>减少锁的持有时间</strong><ul><li><strong>做法</strong>：尽量将<code>synchronized</code>代码块的范围缩小到最小，确保只在确实需要同步的地方加锁，减少锁的持有时间。</li><li><strong>效果</strong>：减小锁的持有时间可以减少线程阻塞的时间，从而提高系统的并发性。</li></ul></li><li><strong>减少锁的粒度</strong><ul><li><strong>做法</strong>：将大锁拆分为小锁，针对不同的数据或资源使用不同的锁，以减少锁的竞争。</li><li><strong>效果</strong>：减小锁的粒度可以减少锁的争用，提高系统的并发能力。</li></ul></li><li><strong>使用更高效的并发工具</strong><ul><li><strong>做法</strong>：在某些场景下，可以用Java的其他并发工具类替代<code>synchronized</code>，如<code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>StampedLock</code>等。</li><li><strong>效果</strong>：这些工具类提供了更多的功能和优化，如可中断的锁获取、超时等待、读写分离等，能够在特定场景下提供更高的性能。</li></ul></li><li><strong>避免不必要的同步</strong><ul><li><strong>做法</strong>：通过仔细分析代码逻辑，避免在不需要同步的地方使用<code>synchronized</code>，例如仅在读操作时不需要同步。</li><li><strong>效果</strong>：减少不必要的同步可以显著提高性能，特别是在读多写少的场景中。</li></ul></li></ol><h3 id="显式锁">显式锁</h3><p><code>java.util.concurrent.locks</code>包提供了一些显式的锁类，如<code>ReentrantLock</code>，它们相比内置锁提供了更多的功能和灵活性。</p><ul><li><strong>ReentrantLock</strong>：一个可重入锁，提供了比<code>synchronized</code>更高级的功能，如公平锁、公平锁模式选择、尝试加锁（<code>tryLock</code>）、超时等待加锁等。</li><li><strong>ReentrantReadWriteLock</strong>：一个读写锁，实现了读写分离，读操作共享锁，写操作独占锁。它提高了读多写少场景下的并发性。</li></ul><h3 id="自旋锁">自旋锁</h3><p><code>CountDownLatch</code> 是 Java 中的一个同步辅助工具，属于<code>java.util.concurrent</code>包中的一部分。它用于让一个或多个线程等待直到其他线程完成一组操作。<code>CountDownLatch</code>主要用于在并发环境中协调多个线程的执行，尤其是当某些线程需要等待其他线程完成某些工作后才能继续执行时。</p><p><code>CountDownLatch</code>使用一个计数器来表示线程需要等待的操作次数。每当一个操作完成时，计数器减一。线程可以在计数器为零之前被阻塞，直到所有操作完成，计数器降到零。</p><h3 id="countdownlatch">CountDownLatch</h3><p><code>CountDownLatch</code>是一种同步辅助工具，允许一个或多个线程等待，直到其他线程完成一组操作。</p><h3 id="主要方法"><strong>主要方法</strong></h3><ol type="1"><li><p><strong><code>await()</code></strong>：使当前线程等待直到计数器的值变为零。线程会在这里被阻塞，直到其他线程调用<code>countDown()</code> 方法使计数器减到零。</p><pre class="line-numbers language-none"><code class="language-none">javaCopy codelatch.await();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>await(long timeout, TimeUnit unit)</code></strong>：使当前线程等待直到计数器的值变为零或等待时间超时。该方法允许设置一个超时时间，超时后线程将继续执行，即使计数器值未变为零。</p><pre class="line-numbers language-none"><code class="language-none">javaCopy codelatch.await(10, TimeUnit.SECONDS);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>countDown()</code></strong>：减少计数器的值。当一个操作完成时，调用<code>countDown()</code>方法将计数器的值减一。如果计数器的值减到零，所有在 <code>await()</code>方法中等待的线程将被唤醒。</p><pre class="line-numbers language-none"><code class="language-none">javaCopy codelatch.countDown();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>getCount()</code></strong>：返回当前计数器的值。</p><pre class="line-numbers language-none"><code class="language-none">javaCopy codelong count = latch.getCount();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-none"><code class="language-none">CountDownLatch latch = new CountDownLatch(3);new Thread(() -&gt; {    // 执行一些操作    latch.countDown();}).start();latch.await(); // 等待所有任务完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CountDownLatch</code>是一个强大的同步工具，用于协调多个线程的执行。当线程需要等待其他线程完成某些操作时，<code>CountDownLatch</code>提供了一个简单有效的机制来实现这种协调。通过控制计数器的值和调用<code>await()</code> 和 <code>countDown()</code>方法，开发者可以轻松地管理线程的依赖和同步。</p><h2 id="redlock">REDLOCK</h2><p>在分布式系统中，当多个节点需要访问共享资源时，需要确保对该资源的访问是互斥的，即同一时间只有一个节点可以访问该资源。分布式锁就是用来实现这一互斥控制的。传统的Redis 分布式锁（如基于 <code>SETNX</code>命令的实现）可能面临单点故障、锁丢失等问题，因此需要一种更为可靠的分布式锁机制。</p><h3 id="redlock-算法"><strong>Redlock 算法</strong></h3><p><strong>Redlock</strong> 的基本思想是使用多个 Redis实例来实现分布式锁，以提高锁的可靠性。其基本步骤如下：</p><ol type="1"><li><strong>部署多个 Redis 实例</strong>：<ul><li>部署 N 个独立的 Redis 实例（通常建议 N 为奇数，如 5 个实例）。</li></ul></li><li><strong>请求锁</strong>：<ul><li>客户端请求锁时，尝试在所有 Redis 实例上设置锁。</li><li>使用 <code>SET key value NX PX &lt;expire&gt;</code> 命令，在每个Redis 实例上设置一个带有超时的锁键。</li></ul></li><li><strong>判断锁的获取成功</strong>：<ul><li>锁获取成功的条件是：在至少 N/2 + 1 个 Redis实例上成功设置了锁。</li><li>如果成功设置的实例数量达到大于 N/2 的数量，则认为锁成功获取。</li></ul></li><li><strong>释放锁</strong>：<ul><li>客户端在使用完共享资源后，需要释放锁。</li><li>释放锁时，客户端需要在所有 Redis 实例上删除锁键。</li></ul></li><li><strong>处理锁的超时和过期</strong>：<ul><li>锁的超时时间（<code>PX</code>）应设置为足够长，以避免在正常情况下锁的超时释放，但也要避免锁在客户端崩溃时不被释放的问题。</li><li>客户端需要处理锁的自动续期和超时问题，以保证锁的有效性。</li></ul></li></ol><h3 id="优点"><strong>优点</strong></h3><ul><li><strong>容错性</strong>：通过多个 Redis实例分散风险，即使部分实例发生故障，只要大多数实例正常工作，锁仍然有效。</li><li><strong>高可用性</strong>：即使某个 Redis实例宕机，其他实例仍然可以继续提供锁服务。</li><li><strong>一致性</strong>：通过多数投票机制（N/2 +1）确保锁的一致性，减少了锁丢失的概率。</li></ul><h3 id="局限性"><strong>局限性</strong></h3><ul><li><strong>复杂性</strong>：与单一 Redis 实例相比，使用多个 Redis实例增加了系统的复杂性和运维成本。</li><li><strong>网络延迟</strong>：由于需要与多个 Redis实例进行交互，可能会增加网络延迟。</li><li><strong>锁的获取时间</strong>：在高负载情况下，获取锁可能需要较长时间，特别是当多个实例的网络延迟较大时。</li></ul><h3 id="使用示例"><strong>使用示例</strong></h3><p>使用 Redlock 时，通常需要使用 Redis 客户端库来实现，例如 <a href="https://github.com/redisson/redisson">Redisson</a> 提供了对Redlock 算法的支持。以下是使用 Redisson 实现 Redlock的一个示例代码片段：</p><pre class="line-numbers language-none"><code class="language-none">javaCopy codeimport org.redisson.Redisson;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.redisson.config.Config;public class RedlockExample {    public static void main(String[] args) {        // 配置 Redisson 客户端        Config config = new Config();        config.useClusterServers()              .addNodeAddress("redis://127.0.0.1:6379")              .addNodeAddress("redis://127.0.0.1:6380")              .addNodeAddress("redis://127.0.0.1:6381");                RedissonClient redisson = Redisson.create(config);        // 获取分布式锁        RLock lock = redisson.getLock("myLock");        try {            // 尝试获取锁            lock.lock();            // 执行受保护的操作            System.out.println("Lock acquired, performing protected operation.");        } finally {            // 释放锁            lock.unlock();        }                // 关闭 Redisson 客户端        redisson.shutdown();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><strong>总结</strong></h3><p><strong>Redlock</strong> 是一种通过多个 Redis实例来实现高可靠性的分布式锁算法，适用于需要高可用性和容错性的分布式系统。通过在多个Redis 实例上设置锁，并采用多数投票机制来保证锁的一致性，Redlock提供了一种在分布式环境中实现互斥控制的可靠方案。</p><h2 id="threadlocl">ThreadLocl</h2><p>ThreadLocal类是用来提供<strong>线程内部的局部变量,即线程本地变量</strong>。这种变量在多线程环境下访问(通过get和set方法访问)时能够保证<strong>各个线程的变量相对独立于其他线程内的变量</strong>，不同线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</p><p><strong>线程隔离机制</strong>，<strong>共享变量的监控</strong></p><p><strong>目的</strong>就是在多线程环境中，无需加锁，也能保证数据的安全性。</p><p><a href="https://www.zhihu.com/search?q=高并发&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A644909120%7D">高并发</a>中会存在多个线程同时修改一个<a href="https://www.zhihu.com/search?q=共享变量&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A644909120%7D">共享变量</a>的场景，这就可能会出现线性安全问题。</p><p>为了解决线性安全问题，可以通过加锁来实现，例如使用synchronized或者Lock。但是加锁的方式可能会导致系统变慢。</p><p>因此可以使用ThreadLocal类访问共享变量，这样会在每个线程的本地，都保存一份共享变量的拷贝副本。这是一种“空间换时间”的方案，虽然会让内存占用大很多，但是由于不需要同步也就减少了线程可能存在的阻塞等待，从而提高时间效率。</p><p>即 存储 key在ThreadLocalMap中然后使用 set getEntry remove操作</p><p>从上面的分析我们已经知道，数据其实都放在了 ThreadLocalMap中，ThreadLocal 的 get、set 和 remove 方法实际上都是通过 ThreadLocalMap的 getEntry、set 和 remove 方法实现的。如果想真正全方位的弄懂ThreadLocal，势必得再对 ThreadLocalMap 做一番理解。</p><p>数据库连接的隔离，比如说spring的jdbc的数据库</p><p>客户端的请求会话的一些隔离</p><p>可以用于hashmap中的线性探测寻址，解决hashmap中的冲突问题</p><p>弱引用key的避免内存泄漏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cas&quot;&gt;1.CAS&lt;/h2&gt;
&lt;p&gt;CAS（Compare-And-Swap，比较与交换）是一种常见的无锁（lock-free）机制，用于实现多线程环境下的原子操作。CAS操作通过硬件支持的原子指令来实现，确保在多线程竞争的情况下，数据的一致性和操作的原子性。</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>redis面试</title>
    <link href="http://suojifeng.xyz/2024/08/20/redis-mian-shi/"/>
    <id>http://suojifeng.xyz/2024/08/20/redis-mian-shi/</id>
    <published>2024-08-20T03:19:38.000Z</published>
    <updated>2024-08-21T07:14:00.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis单机模式集群模式的区别说一下哨兵模式">Redis单机模式、集群模式的区别，说一下哨兵模式</h2><p>Redis是一个高性能的键值存储系统，支持多种部署模式，以满足不同的需求。以下是Redis 单机模式、集群模式的区别，以及哨兵模式的介绍：</p><h3 id="redis-单机模式">1. Redis 单机模式</h3><p><strong>特点</strong>：</p><ul><li><strong>单节点运行</strong>：所有数据都存储在一个 Redis实例中，读写操作也都在该实例上进行。</li><li><strong>简单易用</strong>：配置和管理较为简单，适用于小规模或对高可用性要求不高的场景。</li><li><strong>数据安全性</strong>：如果该节点出现故障，所有数据都可能丢失，除非配备了持久化机制（如RDB 或 AOF）。</li><li><strong>性能瓶颈</strong>：当数据量或访问请求增加时，单节点的性能和容量可能成为瓶颈。</li></ul><p><strong>适用场景</strong>：</p><ul><li>开发环境、测试环境、小规模的生产环境或对高可用性和数据持久化要求不高的应用。</li></ul><h3 id="redis-集群模式">2. Redis 集群模式</h3><p><strong>特点</strong>：</p><ul><li><strong>多节点分布</strong>：Redis集群由多个节点组成，数据分片存储在不同的节点上，每个节点只存储数据的一部分。</li><li><strong>高可用性</strong>：集群模式提供数据的冗余备份，某个节点失效时，其他节点可以继续提供服务。</li><li><strong>自动分片</strong>：数据通过一致性哈希算法自动分片，分布到集群的各个节点，集群可以动态扩展和缩减节点数量。</li><li><strong>支持大规模应用</strong>：可以处理较大的数据量和高并发请求，适用于需要高可用和高性能的大规模应用。</li></ul><p><strong>适用场景</strong>：</p><ul><li>大型互联网应用、分布式系统、需要高可用性和高吞吐量的数据存储场景。</li></ul><h3 id="redis-哨兵模式sentinel">3. Redis 哨兵模式（Sentinel）</h3><p><strong>介绍</strong>： Redis哨兵模式是用于实现高可用性的一种模式，它可以监控多个 Redis实例，并在主节点（Master）发生故障时，自动将某个从节点（Slave）提升为主节点，从而实现故障切换（failover）。</p><p><strong>哨兵模式的主要功能</strong>：</p><ol type="1"><li><strong>监控</strong>：哨兵会持续监控主节点和从节点的运行状态。如果发现主节点不可用，就会通知管理员并进行故障切换。</li><li><strong>自动故障切换</strong>：当主节点发生故障时，哨兵会选择一个从节点提升为新的主节点，并将其他从节点重新配置为复制新的主节点。</li><li><strong>通知</strong>：哨兵可以将事件（如故障切换）通知给客户端，客户端可以根据通知调整连接的主节点。</li><li><strong>配置提供者</strong>：哨兵还可以作为配置提供者，客户端可以通过哨兵获取当前的主节点信息，以便连接到正确的实例。</li></ol><p><strong>工作流程</strong>：</p><ul><li>哨兵以一定频率向 Redis 实例发送 <code>PING</code>命令来判断其状态。</li><li>如果一个哨兵发现某个节点不可达，它会认为该节点“主观下线”（SubjectivelyDown, SDOWN）。</li><li>如果足够多的哨兵（通过配置的<code>quorum</code>参数来控制）认为主节点不可用，则该主节点被标记为“客观下线”（ObjectivelyDown, ODOWN）。</li><li>一旦确定主节点ODOWN，哨兵将会进行故障切换，并推选一个从节点作为新的主节点，完成之后通知其他从节点和客户端。</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要高可用性的生产环境，Redis主从结构下，使用哨兵模式可以自动监控和处理故障，确保系统的稳定性和连续性。</li></ul><h3 id="总结">总结</h3><ul><li><strong>单机模式</strong>：简单、适用于小规模应用，但存在单点故障问题。</li><li><strong>集群模式</strong>：适用于大规模、分布式系统，提供高可用性和可扩展性。</li><li><strong>哨兵模式</strong>：为主从复制提供高可用性支持，能自动处理主节点故障，实现自动故障切换。</li></ul><p>选择哪种模式取决于应用的规模、性能需求、可用性要求等。</p><h2 id="redis的连接池了解过吗">Redis的连接池了解过吗</h2><p>了解过，Redis 连接池是指在应用程序与 Redis数据库之间维护一个连接池，以便重用已有的连接，而不是在每次需要时都创建新的连接。使用连接池可以提高应用程序的性能，特别是在高并发场景下。</p><h3 id="连接池的工作原理">连接池的工作原理</h3><ul><li><strong>连接复用</strong>：连接池中预先创建了一定数量的连接，这些连接可以被多个客户端请求复用。当一个请求完成后，连接不会关闭，而是返回到连接池中等待下一个请求。</li><li><strong>最大连接数</strong>：连接池通常设有最大连接数限制，避免资源耗尽。当连接池中的所有连接都被占用时，新请求会被阻塞，直到有可用连接释放出来，或者抛出超时异常。</li><li><strong>最小连接数</strong>：连接池可以配置最小连接数，保持一定数量的连接始终处于可用状态，以减少请求的等待时间。</li></ul><p>我们项目里面使用的就是 <strong>Lettuce</strong>（Java）</p><p>Lettuce 默认提供异步、同步和响应式 API，同时也支持连接池。</p><pre class="line-numbers language-none"><code class="language-none">lettuce:      pool:        # 连接池最大连接数        # 配置连接池中最大的活跃连接数，也就是最多可以同时创建和使用多少个 Redis 连接。        max-active: 200        # 连接池最大阻塞等待时间（使用负值表示没有限制）        # 设置连接池最大阻塞等待时间，单位为毫秒。-1ms 表示没有限制，即一直等待，直到有连接可用。        max-wait: -1ms        # 这个参数控制着当连接池中空闲连接超过这个数量时，多余的空闲连接将会被释放，避免资源浪费。        # 连接池中的最大空闲连接        max-idle: 10        # 设置连接池中最小空闲连接数，即连接池中至少要保持多少个空闲连接，以确保在需要时有足够的连接可用。        # 连接池中的最小空闲连接        min-idle: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="spring-redis-template的用法">Spring Redis Template的用法</h2><p><code>Spring Redis Template</code> 是 Spring Data Redis提供的一个用于简化 Redis 操作的类，它封装了对 Redis数据库的各种常见操作。通过<code>RedisTemplate</code>，你可以轻松地进行字符串、哈希、列表、集合、有序集合等类型的操作。</p><p>使用 RedisTemplate 的一些注意事项</p><ol type="1"><li><strong>序列化器的配置</strong>：<code>RedisTemplate</code> 默认使用JdkSerializationRedisSerializer 来序列化键和值，如果存储非 Java序列化对象，可能导致数据无法被其他语言客户端识别。因此，通常会配置<code>StringRedisSerializer</code> 或<code>Jackson2JsonRedisSerializer</code> 等序列化器。</li><li><strong>线程安全</strong>：<code>RedisTemplate</code>是线程安全的，可以被多个线程共享使用。</li><li><strong>事务支持</strong>：<code>RedisTemplate</code> 支持 Redis的事务功能，可以通过 <code>redisTemplate.multi()</code> 和<code>redisTemplate.exec()</code> 来开启和提交事务。</li><li><strong>管道操作</strong>：对于批量操作，可以通过管道（pipeline）来提高性能</li></ol><p>在我门的项目中</p><p>这个配置的目的是通过 RedisTemplate 提供一种方便的方式与 Redis进行交互，并且通过自定义序列化器来确保 Redis中的数据以合适的格式存储和读取，特别是使用 JSON格式来存储对象数据，从而提高了数据的可读性和兼容性。</p><p><strong>缓存</strong>：常用于将一些频繁访问的数据缓存到 Redis中，减少对数据库的访问压力。</p><p><strong>分布式锁</strong>：通过 <code>setnx</code>操作实现分布式锁，确保在分布式环境中多个进程之间的互斥。</p><p><strong>计数器</strong>：通过 Redis的原子递增操作实现分布式计数器。</p><p><strong>消息队列</strong>：利用 Redis的列表结构实现简单的消息队列。</p><pre class="line-numbers language-none"><code class="language-none">public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory  connectionFactory)这是一个返回 RedisTemplate&lt;String, Object&gt; 类型的 Bean 方法。RedisTemplate 是 Spring 提供的一个用于执行 Redis 操作的模板类。参数：RedisConnectionFactory 是一个连接工厂接口，用于创建与 Redis 服务器的连接。用于将 Java 对象序列化为 JSON 字符串，或者将 JSON 字符串反序列化为 Java 对象。设置 Redis 值（value）的序列化方式为 jackson2JsonRedisSerializer。JSON 格式存储和读取redisTemplate.setConnectionFactory(connectionFactory);解释：为 RedisTemplate 设置连接工厂，用于创建与 Redis 服务器的连接。作用：绑定 RedisTemplate 和实际的 Redis 连接，使得 RedisTemplate 能够通过连接工厂与 Redis 服务器进行通信。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="redis连接泄露">Redis连接泄露</h2><p>Redis连接泄露指的是在使用Redis连接池的环境中，连接在使用后未能正确释放或归还到连接池，导致连接池中的连接数量逐渐减少，最终可能耗尽所有可用连接，导致应用程序无法再获得新的连接来与Redis服务器通信。</p><p>连接泄露的成因</p><ol type="1"><li><strong>未关闭连接</strong>：某些代码在使用完Redis连接后，没有调用<code>close()</code>方法归还连接到连接池，导致连接无法被其他请求重用。</li><li><strong>异常处理不当</strong>：在连接使用过程中，如果发生异常并且没有正确处理，可能会导致连接无法正确归还。例如，在一个try-catch块中获取了Redis连接，但在catch块中忘记释放连接。</li><li><strong>资源竞争</strong>：当多个线程或进程同时获取连接并尝试释放连接时，可能会出现竞争条件，导致连接无法正常归还。</li></ol><h2 id="redis-实现消息队列与-kafka-的区别">Redis 实现消息队列与 Kafka的区别</h2><p><strong>1. 数据结构</strong></p><ul><li><strong>Redis</strong>：Redis 的消息队列通常使用 <code>LIST</code>数据结构来实现，利用 <code>LPUSH</code> 和 <code>RPOP</code>操作来添加和消费消息。Redis 也可以利用 <code>PUB/SUB</code>实现发布/订阅模式，适合实时消息传递。</li><li><strong>Kafka</strong>：Kafka是一个分布式流处理平台，它使用分区和日志数据结构来实现消息队列。消息以日志形式存储在主题（topic）中，每个主题可以有多个分区，消息在分区中按照时间顺序追加。</li></ul><p><strong>2. 消息持久化</strong></p><ul><li><strong>Redis</strong>：Redis默认将消息存储在内存中，并可以通过持久化机制（RDB 快照、AOF日志）将数据持久化到磁盘。消息在 Redis中是易失的，主要用作缓存或实时处理。</li><li><strong>Kafka</strong>：Kafka主要关注消息的持久化，所有消息都存储在磁盘上，并且可以配置保留策略（例如按时间或空间限制）。消息即使在系统重启后也能保留，适合日志数据存储。</li></ul><p><strong>3. 消息处理</strong></p><ul><li><strong>Redis</strong>：Redis的队列模式支持简单的生产者-消费者模式，使用 <code>LIST</code>实现的队列支持 FIFO顺序，且支持阻塞操作（<code>BRPOP</code>）。<code>PUB/SUB</code>模式的消息会被所有订阅者接收，但没有消息持久化，订阅者在消息发布时需要在线。</li><li><strong>Kafka</strong>：Kafka支持分布式消费模式，消息被写入到多个分区中，消费者可以并行读取不同的分区。Kafka支持消费者组（ConsumerGroups），每个分区的消息只会被一个消费者组中的一个消费者处理，支持水平扩展和高吞吐量。</li></ul><p><strong>4. 性能和扩展性</strong></p><ul><li><p><strong>Redis</strong>：Redis 是单线程的，通过事件循环机制处理I/O操作，具有低延迟和高性能。适用于高频率的数据读取和写入操作，但在消息量很大的场景下，可能会受到内存限制和单线程处理能力的制约。</p></li><li><p><strong>Kafka</strong>：Kafka是分布式的，具有高吞吐量和高可扩展性。可以通过增加分区和消费者实例来扩展处理能力。适用于处理大规模的数据流和日志数据。</p><h2 id="redis是怎么解决key冲突的">redis是怎么解决key冲突的</h2><p>1.<strong>覆盖原则</strong></p><p>Redis 是一个键值存储系统，每个键在 Redis中都是唯一的。当你试图将一个新值存储到已经存在的键上时，Redis会直接覆盖原有的值。这个过程是原子的，也就是说，在同一个时间点，只能有一个值与该键相关联。</p><p>2.<strong>原子操作</strong></p><p>Redis提供了一些原子操作，确保在多客户端并发访问同一个键时不会产生冲突。比如，<code>INCR</code>、<code>DECR</code>、<code>SETNX</code>等命令都是原子的，意味着这些操作在执行时是不可分割的，确保多个客户端并发修改同一个键时不会出现竞争条件。</p><p>3.分布式锁**</p><p>在分布式系统中，Redis可以通过实现分布式锁来控制对关键资源的访问，避免键冲突。Redis 提供了<code>SET</code> 命令的扩展参数，如 <code>NX</code> 和<code>EX</code>，来实现分布式锁。</p><ol start="4" type="1"><li><strong>自动过期</strong></li></ol><p>Redis提供了键的自动过期机制。通过设置键的生存时间（TTL），可以确保某些键在过期后自动删除，从而避免了长期存在的冲突风险。</p></li></ul><h2 id="redis持久化">REDIS持久化</h2><p>RDB和AOF</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redis单机模式集群模式的区别说一下哨兵模式&quot;&gt;Redis单机模式、集群模式的区别，说一下哨兵模式&lt;/h2&gt;
&lt;p&gt;Redis
是一个高性能的键值存储系统，支持多种部署模式，以满足不同的需求。以下是
Redis 单机模式、集群模式的区别，以及哨兵模式的介绍</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://suojifeng.xyz/2024/08/17/aqs/"/>
    <id>http://suojifeng.xyz/2024/08/17/aqs/</id>
    <published>2024-08-17T09:06:53.000Z</published>
    <updated>2024-08-17T09:06:53.639Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="http://suojifeng.xyz/2024/08/08/suo/"/>
    <id>http://suojifeng.xyz/2024/08/08/suo/</id>
    <published>2024-08-08T03:12:52.000Z</published>
    <updated>2024-08-08T03:13:30.952Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，"轻量级"和"重量级"通常用于描述软件结构、线程或同步机制的复杂性和资源消耗。它们的划分主要基于以下几个方面：</p><h3 id="资源消耗">1. 资源消耗</h3><ul><li><p>轻量级（Lightweight）</p><p>：</p><ul><li><strong>内存和CPU使用较少</strong>：轻量级组件或进程通常对系统资源的消耗较低，适用于资源有限的环境。</li><li><strong>简单的实现</strong>：通常设计简单，功能较为专注。</li><li><strong>快速启动和响应</strong>：由于资源开销小，轻量级进程或线程启动和执行速度较快。</li></ul></li><li><p>重量级（Heavyweight）</p><p>：</p><ul><li><strong>高资源消耗</strong>：重量级组件或进程通常需要较多的内存和CPU时间。</li><li><strong>复杂的实现</strong>：通常具有更复杂的功能和更广泛的能力。</li><li><strong>较慢的启动和响应</strong>：由于需要更多的资源，重量级进程或线程可能需要更多的时间来启动和运行。</li></ul></li></ul><h3 id="操作系统级别">2. 操作系统级别</h3><ul><li><p>轻量级线程</p><p>：</p><ul><li>又称为用户级线程，由用户空间的线程库管理，不需要操作系统内核的干预。</li><li>切换速度快，因为不需要系统调用。</li><li>常用于应用程序级并发控制。</li></ul></li><li><p>重量级线程</p><p>：</p><ul><li>又称为内核线程，由操作系统内核管理。</li><li>切换较慢，因为涉及系统调用和上下文切换。</li><li>提供更强的隔离性和稳定性，因为线程的调度由操作系统负责。</li></ul></li></ul><h3 id="锁机制">3. 锁机制</h3><ul><li><strong>轻量级锁</strong>：<ul><li><strong>无锁或自旋锁</strong>：如Java中的CAS操作，通常用于短时间的锁定。</li><li><strong>偏向锁和轻量级锁</strong>：Java中的锁优化技术，在低竞争下使用，避免操作系统内核锁。</li><li><strong>减少锁的开销</strong>：尽量减少使用锁的时间和范围。</li></ul></li><li><strong>重量级锁</strong>：<ul><li><strong>互斥锁（Mutex）</strong>：操作系统提供的同步机制，保证线程安全性。</li><li><strong>阻塞和唤醒</strong>：重量级锁在争用时会导致线程阻塞，需要操作系统的调度。</li><li><strong>线程间通信</strong>：通常用于需要高可靠性的场合。</li></ul></li></ul><h3 id="应用场景">应用场景</h3><ul><li><strong>轻量级方案</strong>：适用于需要快速响应且资源受限的场景，如移动应用中的简单任务调度。</li><li><strong>重量级方案</strong>：适用于需要强隔离和稳定性的场景，如多用户操作系统中的进程管理。</li></ul><h3 id="总结">总结</h3><p>轻量级和重量级的划分不是绝对的，而是相对的，需要根据具体场景和需求进行权衡和选择。在设计软件系统时，常常需要在轻量级和重量级之间取得平衡，以满足性能、资源和复杂度等方面的要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在计算机科学中，&quot;轻量级&quot;和&quot;重量级&quot;通常用于描述软件结构、线程或同步机制的复杂性和资源消耗。它们的划分主要基于以下几个方面：&lt;/p&gt;
&lt;h3 id=&quot;资源消耗&quot;&gt;1. 资源消耗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;轻量级（Lightweight）&lt;/p&gt;
&lt;p&gt;：&lt;</summary>
      
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>秋招提前批</title>
    <link href="http://suojifeng.xyz/2024/08/05/qiu-zhao-ti-qian-pi/"/>
    <id>http://suojifeng.xyz/2024/08/05/qiu-zhao-ti-qian-pi/</id>
    <published>2024-08-05T13:16:41.000Z</published>
    <updated>2024-08-05T13:17:57.893Z</updated>
    
    <content type="html"><![CDATA[<ol type="1"><li>三一重工</li><li>米哈游</li><li>拼多多</li><li>科大讯飞</li><li>4399游戏</li><li>oppo</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;三一重工&lt;/li&gt;
&lt;li&gt;米哈游&lt;/li&gt;
&lt;li&gt;拼多多&lt;/li&gt;
&lt;li&gt;科大讯飞&lt;/li&gt;
&lt;li&gt;4399游戏&lt;/li&gt;
&lt;li&gt;oppo&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
    <category term="找工作" scheme="http://suojifeng.xyz/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>民航项目</title>
    <link href="http://suojifeng.xyz/2024/07/31/min-hang-xiang-mu/"/>
    <id>http://suojifeng.xyz/2024/07/31/min-hang-xiang-mu/</id>
    <published>2024-07-31T11:01:34.000Z</published>
    <updated>2025-08-01T02:05:12.917Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="民航发动机数据管理系统">民航发动机数据管理系统</h1><p>首先这个数据管理系统主要是干什么的</p><ol type="1"><li><p><strong>数据管理</strong>：收集、存储和处理来自飞机发动机的传感器数据。这些数据可能包括发动机性能指标、飞行参数和环境条件。</p></li><li><p><strong>数据分析</strong>：利用机器学习和其他数据分析技术来分析这些数据，以识别模式、预测潜在故障或优化发动机性能。你提到过使用MATLAB 和 Weka 进行进行减推比例和排气裕度的计算与分析。。</p></li><li><p><strong>数据可视化</strong>：使用工具如 Element Plus 和 ECharts来展示分析结果，帮助用户理解数据和分析结果。</p></li><li><p><strong>权限管理</strong>：利用JWT令牌技术，通过自定义拦截器实现用户认证，并使用Sa-Token进行权限控制。</p></li><li><p><strong>集成与接口</strong>：项目涉及前后端的分离开发，并使用技术Apifox 来管理 API 接口文档和测试。</p></li><li><p><strong>系统功能</strong>：实现用户管理、权限管理、操作日志记录和文件存储等功能，通过EasyExcel 进行数据的导入导出。</p></li><li><p><strong>部署与优化</strong>：本地部署Jar包，使用Nginx作为反向代理服务器，增强系统的安全性和性能。</p><p><strong>业务价值</strong>：</p><ul><li>提高民航发动机监控数据的可视化水平，便于运营人员进行快速决策。</li><li>通过数据分析与机器学习，优化发动机性能，降低维护成本。</li></ul></li></ol><h2 id="acars数据航空器通信寻址与报告系统">ACARS数据（航空器通信寻址与报告系统）</h2><p>ACARS用于传输有关飞行操作的信息，如起飞和降落时间、飞行高度、速度等。</p><p>比如说：A00:起飞地面重量，起飞高度，起飞马赫数，发动机的转速，进口温度，离心机的转速</p><p>B00:排气气体温度,推力衰减,风扇转速,发动机风扇和核心的振动，航空器总重</p><h2 id="qar数据快速访问记录器">QAR数据（快速访问记录器）</h2><p>QAR系统记录详细的飞行数据，这些数据通常以高频率采集，提供非常精细的飞行记录。</p><p>马赫，高度，气压，温度，静态空气温度，排气温度， 燃油空气比，燃油流量</p><h2 id="b6105数据故障代码">B6105数据（故障代码）</h2><p>不同时刻发动机的不同传感器的，静态空气温度，气压、无线电高度，马赫数</p><h2 id="减推比例模型">减推比例模型</h2><p>减退比例：可以<strong>延长发动机的寿命</strong>，可以降低发动机在起飞和爬升阶段的推力输出，从而减少发动机部件的磨损和疲劳，延长发动机的使用寿命。在不需要最大推力的情况下使用减推比例，可以<strong>减少燃油消耗</strong>，提高燃油效率。这对于航空公司来说可以显著降低运营成本，尤其是在燃油价格波动较大的情况下。</p><h2 id="排气裕度模型">排气裕度模型</h2><p>是用于评估和优化喷气发动机性能的一种模型。它主要用于确定发动机在特定飞行条件下的排气性能，以及如何保持发动机在设计的性能范围内。排气裕度指的是发动机在特定操作条件下实际排气性能与设计目标性能之间的差距。它通常衡量发动机的实际排气温度、压力或速度与设计规定值之间的差异。</p><p>通过排气裕度模型，可以优化发动机的排气系统设计，以确保发动机在各种飞行条件下都能保持最佳性能。</p><h2 id="数据处理">数据处理</h2><p>ACARS数据不用处理，但是QAR数据需要处理</p><p>ACARS数据不涉及到时间，所以数据量少，但是QAR的数据量涉及到时刻，数据量大</p><p>QAR数据需要进行补全、去噪和归一化，查看减推比例</p><h2 id="数据库">数据库</h2><p>数据库里面的数据包括两种，一种是用来计算减推比例的，一种是用来计算排气裕度的</p><p>其中减推比例计算 在计算过程当中 最大值为26%</p><p>排气裕度 的数据量 最大是 大连飞往海南省和乌鲁木齐 大概5个小时</p><p>其中 一张表的数据量有多少呢 60×60×5×40 = 720000</p><p>我们有很多张表了 其实说 大概的也就 2 - 4小时的比较多</p><p>但是数据有很多 计算起来有很慢怎么解决呢 ：</p><p>1.数据压缩，降采样。去掉无关的数据列，然后是按照固定的时间间隔来抽取数据点而不是处理每一个时间点的数据。</p><p>2.将大数据集按某个维度（如时间或空间）切分为多个小的子集进行并行处理</p><p>可以说是一次旅程就可以有一张表出来：</p><p>那么就是 加入</p><p><strong>飞机信息表</strong>，记录飞机航班号，起飞时间、降落时间、飞机号、飞机信息、发动机类型</p><p><strong>发动机数据表</strong>，里面使用外键引用航班表的信息</p><h3 id="数据库优化">数据库优化</h3><p><strong>定义外键关系</strong>：通过在发动机数据表中使用外键来引用航班表中的主键，将每条发动机数据关联到具体的航班。</p><p><strong>确保唯一标识</strong>：确保每次航班（Flight）和每条发动机数据（EngineData）都有唯一的标识符，用来进行精确的关联。</p><p><strong>索引优化</strong>：在查询频繁的字段（如 <code>FlightID</code>和 <code>Timestamp</code>）上创建索引，以提高查询性能。</p><p><strong>外键约束</strong>：使用外键约束保持数据完整性，确保每条发动机数据都关联到有效的航班。</p><p>对于历史航班和其发动机数据，可以考虑定期进行归档，以减少主数据库的负担。</p><h2 id="数据库使用的设计模式">数据库使用的设计模式</h2><ol type="1"><li><strong>Cache Aside Pattern（旁路缓存模式）</strong></li></ol><ul><li><strong>目的</strong>：在数据访问时优先从缓存中读取数据，当缓存没有数据时，再从数据库中读取，并将结果写入缓存。</li><li><strong>应用场景</strong>：在需要频繁读取而数据变化不频繁的场景中，这种模式可以极大地提高数据访问效率。</li><li>优点：<ul><li>减少了数据库的压力。</li><li>提高了系统性能和响应速度。</li></ul></li><li><strong>示例</strong>：在电商系统中，经常读取但不经常更新的商品信息可以使用旁路缓存模式进行加速。</li></ul><p>2.<strong>Data Access Object Pattern（DAO 模式）</strong></p><ul><li><strong>目的</strong>：将数据访问操作封装到一个独立的对象中，提供数据的抽象接口。</li><li><strong>应用场景</strong>：在需要频繁进行数据库操作的场景下，使用DAO 模式可以将数据访问层与业务逻辑层分离。</li><li>优点：<ul><li>提供了一个统一的数据操作接口，隐藏了数据库访问的复杂性。</li><li>提高了代码的可维护性和可测试性。</li></ul></li><li><strong>示例</strong>：一个 <code>UserDAO</code>对象可以负责所有与用户相关的数据库操作，如查询、插入、更新和删除。</li></ul><ol start="3" type="1"><li><strong>Factory Pattern（工厂模式）</strong></li></ol><ul><li><strong>目的</strong>：为创建不同类型的数据对象提供统一的接口。</li><li><strong>应用场景</strong>：当需要根据不同条件动态创建不同类型的数据对象时，可以通过工厂模式生成这些对象。</li><li>优点：<ul><li>提供灵活的数据对象创建机制，方便维护。</li><li>隐藏具体数据类型的创建细节，符合开闭原则。</li></ul></li><li><strong>示例</strong>：在一个金融系统中，工厂模式可以用于生成不同类型的交易记录对象（如股票交易、债券交易）。</li></ul><h2 id="权限验证">权限验证</h2><p>基于RDBC权限管理的一个平台，分为用户，角色，权限</p><p>用户（多对多）角色（多对多）菜单,基于RBAC设计的，通过将权限分配给角色，角色分配给用户，一般是多对多的关系</p><p><strong>用户</strong>：平台上的个人账户，具有登录和使用系统的能力。</p><p>用户ID 用户名 密码（加密存储） 电子邮件 角色（一个或多个）</p><p>管理员：</p><p>​ 访问系统的所有功能</p><p>​ 管理用户账户（创建、编辑、删除）</p><p>​ 分配和修改角色</p><p>​ 发动机数据的上传和管理</p><p>操作员：</p><p>​ 和数据相关的一些工作</p><p>游客：</p><p>​ 使用相关功能</p><p>​ 导出数据，但不能上传</p><p>权限的话呢：增删改查肯定是要有的，包括数据和角色的表单管理</p><p>问题在于 是怎么样去实现权限验证的呢？</p><p>\1.<strong>检测权限</strong>：用户访问资源时，我们首先要检查用户的令牌（SaToken）是否有访问该资源的权限。</p><p>\2.<strong>返回权限拒绝</strong>：如果发现令牌不匹配或者用户无权限访问该资源，服务器会返回一个权限拒绝的状态码，比如403Forbidden，和一条相关的错误信息，提示用户无权限。</p><p>\3.<strong>前端处理</strong>：前端收到服务器返回的403状态码后，可以拦截请求并展示一条用户友好的错误信息，告知用户当前没有访问该资源的权限。</p><h2 id="负责人">负责人</h2><p>你作为负责人，你应该要做的是什么职责呢？</p><p>确定项目架构，搭建整体框架，基于 RBAC 权限模型设计用户数据库；</p><p>组员的工作：①前端页面的展示②机器学习算法集成③两个人做后端</p><h2 id="前端到后端数据的传输">前端到后端数据的传输</h2><p>首先是前端的交互，然后通过vue3的代码进行数据传输，使用http协议向后端发送数据（使用axios发起请求）</p><p>DTO 接收前端表单实体，Entity 与数据库交互，VO 用于前端展示</p><p>然后是数据传输：数据传输请求包括下面的主要部分</p><p><strong>请求方法</strong>：例如POST、PUT、GET等。</p><p><strong>请求URL</strong>：后端API的端点地址。</p><p><strong>请求头</strong>：包含Content-Type（如application/json）和其他元数据。</p><p><strong>请求体</strong>：包含实际发送的数据（通常是JSON格式）。</p><p>然后后端接受到请求数据之后呢，controller层进行处理，做一些工作</p><p>处理完请求后，后端会生成响应并发送回前端。响应通常包括状态码（如200OK）、响应头和响应体（如操作结果、成功消息、错误信息等）。</p><p>前端接收到后端的响应后，会根据响应的内容更新用户界面。例如，显示成功消息、更新视图、处理错误等。</p><h2 id="操作日志记录">操作日志记录</h2><p>登录日志：雪花算法id，用户名，服务，ip，日期，登录信息</p><p>操作日志包括：操作用户名，用户服务，用户ip，用户地理位置， 操作，操作具体内容，</p><p>自定义配置<strong>elasticsearch</strong>，实现长连接 AOP 调用 log服务实现 + SLF4J</p><p>怎么使用的呢？主要是使用<strong>Elasticsearch</strong>分布式搜索和分析引擎，来存储和分析日志数据</p><p><strong>Spring Data Elasticsearch</strong> 封装了基本功能，</p><p><strong><code>countLogin</code></strong>：</p><ul><li>该方法统计符合特定条件的登录日志。默认情况下，它会统计最近一个月的登录情况。</li><li>使用 <code>BoolQueryBuilder</code>创建查询，过滤出状态为成功且操作类型为登录的记录。</li><li>使用 <code>AggregationBuilders</code>创建一个聚合，以用户名进行分组并统计每组的数量。</li><li>查询通过 <code>restTemplate.search</code> 方法执行，结果在<code>terms</code> 的 <code>bucket</code> 中返回。</li></ul><h2 id="websocket">Websocket</h2><p>在这里面websocket起到了什么作用呢？</p><p>WebSocket是一种协议，它为<strong>客户端和服务器之间的实时、双向通信提供了一个持久化的连接</strong>。与传统的HTTP请求-响应模型不同，WebSocket允许在单个连接上进行双向、全双工的数据交换。这使得WebSocket非常适合需要实时数据更新的应用场景，如在线聊天、实时通知、金融市场数据推送等。</p><p><strong>连接建立</strong>：客户端通过发起一个WebSocket握手请求与服务器建立连接。握手请求是一个标准的HTTP请求，但带有<code>Upgrade</code> 头，指示服务器将连接升级到WebSocket协议。</p><p><strong>握手响应</strong>：服务器回应一个WebSocket握手响应，确认升级协议并建立连接。</p><p><strong>数据传输</strong>：一旦连接建立，客户端和服务器可以通过WebSocket连接进行双向数据传输，而无需重新建立连接。数据可以是文本、二进制等格式。</p><p><strong>连接关闭</strong>：当通信完成或出现错误时，任何一方可以主动关闭WebSocket连接。连接关闭的过程类似于普通的HTTP连接关闭。</p><p>优点在于下面几点：</p><p><strong>实时性</strong>：WebSocket提供了低延迟的实时数据传输。这使得应用程序能够即时更新数据，而不需要频繁地轮询服务器。</p><p><strong>双向通信</strong>：WebSocket允许服务器主动向客户端推送数据，而不需要客户端发起请求。这对于需要服务器推送实时更新的应用（如实时聊天、在线游戏等）非常有用。</p><p><strong>减少开销</strong>：与传统的HTTP请求-响应模型相比，WebSocket的握手过程只发生一次，之后的数据传输不需要重复的HTTP头。这减少了网络开销和带宽消耗。</p><p><strong>持久连接</strong>：WebSocket连接在建立后是持久的，直到被显式关闭。这意味着数据传输可以在多个消息中维持一个连接，而无需重新建立连接。</p><h2 id="satoken">Satoken</h2><p>Sa-Token 是一个轻量级的 Java 权限管理框架，提供了基于 Token的认证和权限控制。它可以与 Spring Boot 等框架无缝集成，支持 JWT（JSONWeb Tokens）用于身份验证和授权。</p><p><strong>1.主要是 Sa-Token 整合 jwt</strong></p><p>Sa-Token 可以与 JWT 集成，使用 JWT 作为认证Token，确保请求的合法性和用户身份的验证。</p><p><strong>2.注册 Sa-Token 拦截器，校验规则为 StpUtil.checkLogin()登录校验</strong>。</p><p>通过配置 Sa-Token拦截器来拦截和处理请求，实现统一的权限管理和认证检查。</p><p>用 <code>StpUtil.checkLogin()</code> 方法检查用户是否已登录</p><p><strong>3.SaCheckPermission</strong></p><p>通过 <code>SaCheckPermission</code>注解进行权限控制，确保用户有权限访问某些资源。</p><p><strong>4.集成在全局异常处理当中</strong></p><p>GlobalExceptionHandler处理在 Spring Boot应用中出现的各种异常，并返回统一格式的错误响应。</p><h2 id="aop">AOP</h2><pre class="line-numbers language-none"><code class="language-none">@AfterReturning(pointcut = "@annotation(controllerLog)", returning = "commonResult")public void doAfterReturning(JoinPoint joinPoint, Log controllerLog, Object commonResult) {    if (Objects.isNull(commonResult)) {        HttpServletResponse response = ServletUtil.getResponse();        // 没有统一返回类则必须有相关response信息        if (Objects.isNull(response)) {            log.warn("LogAspect#doAfterReturning切面方法无返回值且未能获得Http响应信息，无法记录日志");            return;        }        // response状态码信息转换为CommonResult格式        commonResult = new CommonResult&lt;&gt;(response.getStatus(), response.getContentType(), null);    }    // 若返回值不是CommonResult类型，则根据返回值类型自动转换为CommonResult    if (!(commonResult instanceof CommonResult)) {        switch (commonResult) {            case Integer num -&gt; commonResult = CommonResult.of(num, "执行成功", "执行失败");            case Boolean flag -&gt; commonResult = CommonResult.of(flag, "执行成功", "执行失败");            default -&gt; commonResult = new CommonResult&lt;&gt;(HttpStatus.SUCCESS, "执行成功", commonResult);        }    }    handleLog(joinPoint, controllerLog, null, (CommonResult&lt;?&gt;) commonResult);}/** * 请求出现异常后执行 * * @param joinPoint 切点 * @param e         异常 */@AfterThrowing(value = "@annotation(controllerLog)", throwing = "e")public void doAfterThrowing(JoinPoint joinPoint, Log controllerLog, Exception e) {    handleLog(joinPoint, controllerLog, e, null);}/** * 使用虚拟线程 */private final ExecutorService virtualThreadPerTaskExecutor = Executors.newThreadPerTaskExecutor(NamedThreadFactory.newVirtualThreadFactory("log"));/** * 日志处理 * 1.记录请求上下文信息 * 2.开启虚拟线程异步处理 * 3.判断日志类型，解析注解中的Spring EL表达式，获取日志内容 * 4.调用日志服务保存日志 * * @param joinPoint     切点 * @param controllerLog 注解 * @param e             异常 * @param commonResult  统一返回值 */protected void handleLog(JoinPoint joinPoint, Log controllerLog, Exception e, CommonResult&lt;?&gt; commonResult) {    // 无法异步获取request以及登录用户，先记录request相关信息    String ip = IpUtil.getIpAddress(ServletUtil.getRequest());    int userId = 0;    String requestMethod = ServletUtil.getRequest().getMethod();    // 操作日志时提前记录用户id    if (controllerLog.businessType() != BusinessType.LOGIN &amp;&amp;            controllerLog.businessType() != BusinessType.LOGOUT &amp;&amp;            controllerLog.businessType() != BusinessType.ACCESS) {        userId = userIdSearcher.getUserId();    }    int currentUserId = userId; // 满足lambda等效静态    // 异步处理后续操作    virtualThreadPerTaskExecutor.execute(() -&gt; {        try {            SysLog sysLog = new SysLog();            sysLog.setOperate(controllerLog.businessType().getKey());            sysLog.setIp(ip);            sysLog.setLocation(IpUtil.getRegionAndIsp(ip));            // 获取方法入参，key为参数名，value为参数值            LinkedHashMap&lt;String, Object&gt; params = ReflectUtil.resolveParams(joinPoint);            StandardEvaluationContext context = ReflectUtil.paramsAlias(params);            // 用自定义的Spring EL表达式解析字符串            sysLog.setService(ReflectUtil.resolveValue(controllerLog.service(), context, String.class));            // 是否抛出异常，若未抛出异常则通过状态码判断响应状态            if (Objects.nonNull(e)) {                sysLog.setStatus(BusinessStatus.FAIL.getKey());                sysLog.setContent(StringUtil.handleExpMsg(e.getMessage()));            } else if (commonResult.isSuccess()) {                // 请求处理成功                sysLog.setStatus(BusinessStatus.SUCCESS.getKey());                sysLog.setContent(ReflectUtil.resolveValue(controllerLog.content(), context, String.class));            } else {                // 请求处理失败                sysLog.setStatus(BusinessStatus.FAIL.getKey());                sysLog.setContent(commonResult.getMsg());            }            String username;            // 登录日志处理（含调用doAppLogin的登录）            if (BusinessType.LOGIN == controllerLog.businessType()) {                // 登录成功，直接从返回结果中获取用户信息                username = Objects.isNull(e) &amp;&amp; commonResult.isSuccess() ? ((UserVO) commonResult.getData()).getUsername()                        // 否则用自定义的Spring EL表达式解析参数获取异常的用户名                        : ReflectUtil.resolveValue(controllerLog.operator(), context, String.class);            }            // 注销日志处理，注销时会返回用户id            else if (BusinessType.LOGOUT == controllerLog.businessType()) {                Integer id = (Integer) commonResult.getData();                username = usernameSearcher.getUsername(id);            }            // 其他操作日志处理，可直接通过请求获得用户id            else {                // 访问日志可通过返回结果获取用户信息或者日志注解中的operator获取用户名                username = BusinessType.ACCESS == controllerLog.businessType() &amp;&amp; Objects.isNull(e) &amp;&amp; commonResult.isSuccess()                        ? ((UserVO) commonResult.getData()).getUsername()                        : StringUtil.isNotBlank(controllerLog.operator()) ? ReflectUtil.resolveValue(controllerLog.operator(), context, String.class)                        : usernameSearcher.getUsername(currentUserId);                // 获取请求方法类名                String className = joinPoint.getTarget().getClass().getName();                // 获取请求方法名                String methodName = joinPoint.getSignature().getName();                // 记录的方法格式为：类名#方法名格式                sysLog.setMethod(STR."\{className}#\{methodName}");                sysLog.setRequestMethod(requestMethod);            }            sysLog.setUsername(username);            logFeignService.saveLog(sysLog);        } catch (Exception exception) {            log.error("日志存储失败", exception);        }    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个AOP日志切面代码的主要功能是对标记了特定注解的方法进行日志记录，分别在方法正常返回和抛出异常的情况下执行不同的处理逻辑。以下是代码中关键部分的解释：</p><h3 id="afterreturning注解">1.<strong><code>@AfterReturning</code>注解</strong></h3><p><code>@AfterReturning</code>表示该方法将在目标方法成功返回之后执行。</p><ul><li><strong><code>pointcut = "@annotation(controllerLog)"</code></strong>：该切面会拦截所有被标注了自定义注解（比如<code>@Log</code>）的方法。</li><li><strong><code>returning = "commonResult"</code></strong>：表示捕获目标方法的返回值<code>commonResult</code>。</li><li>在方法返回后，<code>doAfterReturning</code>会检查返回值是否为空（<code>commonResult</code>），如果为空，则通过<code>HttpServletResponse</code>生成一个默认的返回对象。如果返回值不是<code>CommonResult</code>类型，则进行相应的转换为统一格式。</li><li>最终调用<code>handleLog</code>方法来处理日志记录。</li></ul><h3 id="afterthrowing注解">2.<strong><code>@AfterThrowing</code>注解</strong></h3><p><code>@AfterThrowing</code>表示该方法会在目标方法抛出异常时执行。</p><ul><li><strong><code>throwing = "e"</code></strong>：捕获目标方法抛出的异常<code>e</code>。</li><li>方法体中通过<code>handleLog</code>处理异常信息并记录日志。</li></ul><h3 id="日志异步处理">3. <strong>日志异步处理</strong></h3><p>日志的核心处理逻辑位于<code>handleLog</code>方法中。通过虚拟线程池（<code>ExecutorService</code>）异步处理日志，以提高性能，避免阻塞主线程。</p><h3 id="日志处理逻辑">4. <strong>日志处理逻辑</strong></h3><p>在<code>handleLog</code>方法中，日志记录的详细逻辑包括：</p><ul><li><strong>获取请求的上下文信息</strong>：包括客户端IP地址、请求方法、用户ID等。</li><li><strong>判断业务类型</strong>：通过<code>controllerLog.businessType()</code>，判断是否为登录、注销、访问等不同类型的业务操作，分别处理用户信息的获取逻辑。</li><li><strong>解析注解中的Spring EL表达式</strong>：用自定义的SpringEL表达式解析注解中定义的日志内容，这样可以动态获取方法的参数、返回值，形成灵活的日志内容。</li><li><strong>处理异常或成功情况</strong>：如果抛出了异常，日志将记录为失败；如果没有异常，则根据返回值的状态记录成功或失败。</li><li><strong>日志异步保存</strong>：通过调用日志服务（<code>logFeignService.saveLog(sysLog)</code>）异步保存日志信息。</li></ul><h3 id="方法的核心作用">5. <strong>方法的核心作用</strong></h3><ul><li><strong><code>doAfterReturning</code></strong>：在目标方法正常返回后进行日志记录，统一处理返回结果，并调用日志处理逻辑。</li><li><strong><code>doAfterThrowing</code></strong>：在目标方法抛出异常时捕获异常信息，记录日志。</li><li><strong><code>handleLog</code></strong>：负责处理所有日志信息的细节，包括请求上下文信息、方法参数、用户信息、执行结果等。通过虚拟线程池进行异步处理，提高日志处理的效率。</li></ul><h3 id="虚拟线程">6. <strong>虚拟线程</strong></h3><ul><li>使用<code>virtualThreadPerTaskExecutor</code>创建虚拟线程（JDK中的轻量级线程），通过异步执行日志的保存操作，避免日志处理对应用性能产生影响。</li></ul><h3 id="总结">总结</h3><p>该AOP切面通过<code>@AfterReturning</code>和<code>@AfterThrowing</code>注解分别处理方法正常执行和抛出异常的情况，结合虚拟线程实现异步日志记录，解析方法参数、返回值及异常信息，并将这些信息保存为操作日志。这种实现方式减少了手动日志代码的冗余，并提升了日志记录的灵活性和性能。</p><h2 id="redis">Redis</h2><p>Redis部署在docker里面，默认端口</p><p>整合的是 satoken和redis链接</p><p>redis整合的是 <strong>jackson序列化方式</strong></p><p>存储的是 redis的信息：用户的角色信息与权限列表，jwt-token请求时间</p><p>每次权限验证的时候重写satoken的接口，每次<strong>查权限</strong>和<strong>登录信息</strong>的时候从redis缓存里面查</p><p>还有就是经常查询的数据库：比如说是航班表的信息，但是实时数据可能不会存储到里面</p><p>在application.yml里面部署</p><p>使用Redis实现Session共享可以解决分布式应用程序中的Session一致性问题，同时提供高可用性和扩展性。Redis是一个快速、可靠且功能强大的缓存和数据存储系统，非常适合用于这种场景。</p><p>首先是用户信息，和权限信息，key/value形式，使用哈希的形式</p><p>然后是 用户会话登录形成的会话令牌即token，可以使用string进行Jackson序列化存储</p><p>首先是</p><p>热点数据：</p><p>\1.<strong>缓存热点数据</strong>：使用缓存系统（如Redis或Memcached）将热点数据缓存起来，加快访问速度，减少数据库压力。</p><p>\2.<strong>数据分片</strong>：将数据分成多个分片，分布在不同的数据库或者服务器上，减少单一数据节点的压力。</p><p>\3.<strong>负载均衡</strong>：在应用层增加负载均衡器，将请求分发到不同的服务器进行处理，以均衡负载，减少单个服务器的压力。</p><p>\4.<strong>数据复制</strong>：创建热点数据的多个副本，放在不同的服务器上，从而分散读写压力。</p><p>\5.<strong>异步处理</strong>：对于非实时性的数据更新，可以采用异步处理，减少瞬间高并发的压力。</p><p>\6.<strong>热点数据分布策略</strong>：根据热点数据的分布规律，通过调整数据库表的结构或者查询逻辑，从根本上避免产生热点数据。</p><h3 id="存储的数据类型具体大小">存储的数据类型，具体大小</h3><h3 id="如何保证缓存与数据库一致性">如何保证缓存与数据库一致性</h3><p>先更新数据库，然后再删除缓存</p><p>将更新缓存和删除缓存</p><p><strong>异步重试</strong>。什么是异步重试？</p><p>其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。</p><p>或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。</p><p>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？</p><p>这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。</p><p>所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p><ul><li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li><li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li><li><figure><img src="/2024/07/31/min-hang-xiang-mu/Blog\source_posts\民航项目\image-20240911222304193.png" alt="image-20240911222304193"><figcaption aria-hidden="true">image-20240911222304193</figcaption></figure></li></ul><p>1.简单：适应并发量一致性都不是很高</p><p>写的时候删除缓存，然后再更新DB</p><p>读的时候先读缓存，然后读DB，异步将数据刷会缓存</p><p>问题在于 中间有一个步骤出错了怎么办，读写，写写并发会出现不一致的问题</p><p>2.一般：</p><p>引入日志binlog，通过解析binlog来刷新缓存</p><p>写的时候第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok或者直接分析binlog也可以)的binlog，通过分析binlog我们解析出需要需要刷新的数据，然后读主库把最新的数据写入缓存。</p><p>读的时候读的时候先读缓存，然后读DB，异步将数据刷会缓存</p><p>3.困难</p><p>利用<strong>MQ</strong>集成分布式系统 将所有“读数据库” +“写数据库缓存”的步骤<strong>串行化</strong></p><figure><img src="/2024/07/31/min-hang-xiang-mu/Blog\source_posts\民航项目\image-20240821141457071.png" alt="image-20240821141457071"><figcaption aria-hidden="true">image-20240821141457071</figcaption></figure><p>写的时候第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok)的binlog，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就<strong>消费MQ</strong>，解析MQ消息来读库获取相应的数据刷新缓存。</p><p>读的时候第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</p><p>4.困难进阶</p><p>阿里开源的cannl组件</p><p>基于binlog可以将数据库同步到其他各类数据库中，目标数据库支持mysql,postgresql,oracle,redis,MQ,ES等</p><p>canal分成服务端deployer和客户端adapter，我们可以部署多个，同时为了方便管理还提供了一个管理端admin</p><figure><img src="/2024/07/31/min-hang-xiang-mu/Blog\source_posts\民航项目\3fc70f3217cb46364b4f6a3c6d0f3bf6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>不同点就在于我们加一个缓存，将近期被修改的数据进行标记锁定。读的时候，标记锁定的数据强行走DB，没锁定的数据，先走缓存，加上标志cache_0来规定</p><h2 id="注册登录">注册登录</h2><p>使用邮箱注册，需要验证码，验证码存放在redis中，在redis中设置有效时间为一分钟</p><p>忘记密码：与注册部分同理，也是邮箱验证码</p><p>验证码：配置 SMTP 服务器地址+qq邮箱小号</p><p>用户登陆后后端会生成token与session存入redis中，同时token还会传送给前端，前端每次发送请求请求头中都会带着token。之后会与redis中存储的token进行对比验证，如果相同并且没有过期，就会放行。</p><h2 id="cookiesessiontoken">cookie、session、token</h2><p>cookie是客户端，浏览器。不安全根据cookie登录不同的账号，容量有限。不能完全依赖cookie</p><p>session 响应头里面加入 set-cookie。 主要是<strong>sessionID</strong>可以是map存出用户信息，存储在服务端，安全。但是扩展性差，跨域限制。</p><p>多个服务器 =&gt; 集群session设置。</p><p>使用JWT token 进行传递字符串。</p><p>base64加密。</p><h2 id="minio">MINIO</h2><p>服务地址，<strong>用户名，密码，存储桶</strong></p><p>分布式对象存储</p><p>包括分片续传和单点上传</p><h2 id="http协议">http协议</h2><p>HTTP 是超⽂本传输协议，信息是明⽂传输</p><p>HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了SSL/TLS 安全协议</p><ol type="1"><li>HTTP1.1（用的最多）<ol type="1"><li>相比于1.0，新增了那些功能？<ul><li>提出了<strong>⻓连接</strong>的通信⽅式，也叫持久连接。只要任意⼀端没有明确提出断开连接，则保持TCP 连接状态。</li><li>⻓连接的⽅式这使得<strong>管道（pipeline）⽹络传输</strong>成为了可能。在同⼀个TCP连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以<strong>减少整体的响应时间。</strong></li><li>增加了host字段。1.0认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。而虚拟主机技术的发展，一台物理服务器上有多个虚拟主机，共享一个IP，于是增加host字段区分。</li><li>没有请求优先级控制</li></ul></li></ol></li><li>HTTP2.0<ol type="1"><li>HTTP/2 协议是<strong>基于 HTTPS 的</strong>，所以 HTTP/2的安全性也是有保障的。</li><li>相比于1.1的性能改进：<ul><li>引入二进制分帧层。HTTP/2 不再像 HTTP/1.1⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了<strong>⼆进制格式</strong>，头信息和数据体都是⼆进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong>。</li><li>HTTP/2 多个HTTP请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的HTTP 请求。</li></ul></li></ol></li></ol><h2 id="nginx">nginx</h2><p>电脑和前端页面访问的中介就是 nginx <strong>高性能web</strong></p><p>部署完打包之后 使用Nginx作为反向代理服务器，将请求转发给SpringBoot项目。</p><p>首先，安装Nginx，并编辑配置文件（一般位于/etc/nginx/nginx.conf），添加以下配置：</p><pre class="line-numbers language-none"><code class="language-none">http {    server {        listen 80;        server_name your_domain_name;        location / {            proxy_pass http://localhost:9090;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将your_domain_name替换为你的域名，your_project_port替换为项目运行的端口。</p><p>保存并退出配置文件后，重启Nginx服务：</p><p>考虑为你的 Nginx 服务器配置 SSL/TLS 证书以实现 HTTPS。可以使用 <a href="https://letsencrypt.org/">Let's Encrypt</a> 提供免费的 SSL证书。</p><p>如果有多个后端服务器，可以使用 Nginx 来实现简单的负载均衡。只需在<code>proxy_pass</code> 配置中定义多个上游服务器即可。</p><pre><code># HTTPS server##server {#    listen       443 ssl;#    server_name  localhost;#    ssl_certificate      cert.pem;#    ssl_certificate_key  cert.key;#    ssl_session_cache    shared:SSL:1m;#    ssl_session_timeout  5m;#    ssl_ciphers  HIGH:!aNULL:!MD5;#    ssl_prefer_server_ciphers  on;#    location / {#        root   html;#        index  index.html index.htm;#    }#}</code></pre><p>使用nginx解决跨域问题。也是在conf里面修改配置问题</p><p><strong><code>Access-Control-Allow-Origin</code></strong>：允许指定的源访问资源。<code>*</code>表示允许所有源访问，你也可以指定具体的域名（如<code>https://example.com</code>）。</p><p><strong><code>Access-Control-Allow-Methods</code></strong>：指定允许的HTTP 方法。</p><p><strong><code>Access-Control-Allow-Headers</code></strong>：指定允许的请求头。</p><p><strong><code>Access-Control-Max-Age</code></strong>：指定预检请求的缓存时间。</p><h2 id="模型计算">模型计算</h2><p>ACARS数据那到底是怎么计算呢，主要是 包括单值预测和多值预测</p><p>其实和机器学习里面的东西是一样的。</p><p>基本上是调用<strong>matlab的模型，包括SCN和BP神经网络，和weka里面的机器学习模型</strong></p><p>怎么调用matlab的模型呢，首先是要把模型给打包，然后放入到pom.xml文件中，在controller中就可以调用了</p><p>weka应该怎么使用呢，主要是应该首先下载weka，然后也是放到pom.xml文件，一般处理的是arff文件</p><h2 id="部署问题">部署问题</h2><p>主要还是部署问题，</p><p>maven的package功能</p><p>得到相关的jar包，在linux或者其他系统通过java命令运行项目jar包</p><pre class="line-numbers language-none"><code class="language-none">java -jar boot-0.0.1-SNAPSHOT.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后前端是 下载 nginx作为前端代理</p><h3 id="前端">前端</h3><p>前端打包的 Node.js和npm管理</p><pre class="line-numbers language-none"><code class="language-none">npm run build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将打包完成的 <strong>dist</strong>文件夹放到 nginx的 html文件夹里面，然后修改nginx.conf文件</p><p>在命令行启动 start nginx</p><p>然后就可以进去，主要是在云服务器中 要下载 mysql和redis这两个要启动</p><p>这就是前端静态代码的运行</p><h2 id="项目难点">项目难点</h2><p>回答时，<strong>可以采用 STAR 法则</strong>：</p><ul><li><strong>Situation（情境）</strong>：简要介绍项目的背景和目标。</li><li><strong>Task（任务）</strong>：明确自己在项目中的职责和任务。</li><li><strong>Action（行动）</strong>：详细描述为实现目标所采取的具体行动和技术手段。</li><li><strong>Result（结果）</strong>：重点阐述项目取得的成果和带来的价值。</li></ul><h3 id="数据库设计">1.数据库设计</h3><p><strong>Situation（情境）</strong></p><p>民航发动机在飞行过程中会产生大量的一秒一次（实时）的数据。这些数据用来计算减推比例和排气裕度，项目的目标是建立一个高效的数据存储和管理系统，以便对不同发动机和航班的数据进行存储、记录、分析和可视化。</p><p><strong>Task（任务）</strong></p><p>怎么样去建立数据库，可以灵活写入、快速查询的数据库架构。</p><p><strong>Action（行动）</strong></p><p>在mysql的数据库的设计中，包括</p><p><strong>1.飞机信息表</strong>，记录航班号，起飞时间、降落时间、飞机号、飞机信息、发动机类型</p><p><strong>2.发动机数据表</strong>，记录发动机每秒的数据，然后主键是ID,外键是航班号</p><p>在发动机数据表中使用<code>flight_id</code>作为外键，引用飞机信息表中的<code>flight_id</code>，以确保每条发动机数据都关联到特定的飞机。然后从特定的飞机信息表上可以得到飞机信息</p><p><strong>优化：</strong></p><p>1.在写入的时候批量写入，而不是每秒直接写入数据库，1000条左右</p><p>2.对经常需要查询的字段 比如说航班号啊，时间加入索引，优化时间</p><p>3.上面分数据库的设计</p><p>4.定义外键约束。（缺点就是维护起来比较困难）</p><p><strong>Result（结果）</strong></p><p>执行起来更加迅速，数据库结构更加清晰。</p><h3 id="数据库和redis缓存不一致的问题">2.数据库和redis缓存不一致的问题</h3><p><strong>Situation（情境）</strong></p><p>民航发动机在飞行过程中会产生大量的一秒一次（实时）的数据。<strong>数据更新mysql数据库的时候和缓存不一致的情况。</strong>或者是mysql和redis的分布式事务的问题</p><p><strong>Task（任务）</strong></p><p>怎么保证数据和缓存的一致性</p><p><strong>Action（行动）</strong></p><figure><img src="/2024/07/31/min-hang-xiang-mu/Users\suoshi\AppData\Roaming\Typora\typora-user-images\image-20240817183541276.png" alt="image-20240817183541276"><figcaption aria-hidden="true">image-20240817183541276</figcaption></figure><p><strong>Result（结果）</strong></p><p>保证了一致性</p><h3 id="多线程插入民航发动机的数据">3.多线程插入民航发动机的数据</h3><p>民航公司，会定时的 批量的 传输一部分的 发动机数据 上万条<strong>数据库化持久化操作</strong></p><p>提升速度 多线程：</p><p>事务失效：其他的怎么去快速感知，然后解决。</p><p>1.编程式事务：定义一个全局的事务管理器，让所有子线程都用这一个事务管理器。缺点：还是串行操作数据库</p><p>2.创建线程池：</p><p>每个线程处理 2000条数据</p><p>使用count down latch <img src="/2024/07/31/min-hang-xiang-mu/Blog\source_posts\民航项目\image-20240909141009461.png" alt="image-20240909141009461"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;民航发动机数据管理系统&quot;&gt;民航发动机数据管理系统&lt;/h1&gt;
&lt;p&gt;首先这个数据管理系统主要是干什么的&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据管理&lt;/strong&gt;：收集、存储和处理来自飞机发动机的传</summary>
      
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://suojifeng.xyz/2024/06/07/redis/"/>
    <id>http://suojifeng.xyz/2024/06/07/redis/</id>
    <published>2024-06-07T08:18:51.000Z</published>
    <updated>2024-08-07T08:44:05.830Z</updated>
    
    <content type="html"><![CDATA[<p>1.缓存</p><figure><img src="/2024/06/07/redis/缓存穿透.jpg" alt="缓存穿透"><figcaption aria-hidden="true">缓存穿透</figcaption></figure><figure><img src="/2024/06/07/redis/布隆过滤器.jpg" alt="布隆过滤器"><figcaption aria-hidden="true">布隆过滤器</figcaption></figure><p>（redission）布隆过滤器：通过对id计算hash值计算，通过id得到值在bitmap中置1，但是会误判（误判率5%以内）</p><p>攻击数据库</p><figure><img src="/2024/06/07/redis/缓存穿透面试解答.jpg" alt="缓存穿透面试解答"><figcaption aria-hidden="true">缓存穿透面试解答</figcaption></figure><p>缓存击穿</p><figure><img src="/2024/06/07/redis/缓存击穿.jpg" alt="缓存击穿"><figcaption aria-hidden="true">缓存击穿</figcaption></figure><figure><img src="/2024/06/07/redis/击穿解决办法.jpg" alt="击穿解决办法"><figcaption aria-hidden="true">击穿解决办法</figcaption></figure><figure><img src="/2024/06/07/redis/击穿面试解答.jpg" alt="击穿面试解答"><figcaption aria-hidden="true">击穿面试解答</figcaption></figure><figure><img src="/2024/06/07/redis/缓存雪崩.jpg" alt="缓存雪崩"><figcaption aria-hidden="true">缓存雪崩</figcaption></figure><figure><img src="/2024/06/07/redis/雪崩解决.jpg" alt="雪崩解决"><figcaption aria-hidden="true">雪崩解决</figcaption></figure><p>mysql与redis（双写一致性）业务背景 缓存和数据库写</p><figure><img src="/2024/06/07/redis/双写延迟双删.jpg" alt="双写延迟双删"><figcaption aria-hidden="true">双写延迟双删</figcaption></figure><p>采用分布式锁：</p><figure><img src="/2024/06/07/redis/分布锁.jpg" alt="分布锁"><figcaption aria-hidden="true">分布锁</figcaption></figure><figure><img src="/2024/06/07/redis/异步消息.jpg" alt="异步消息"><figcaption aria-hidden="true">异步消息</figcaption></figure><figure><img src="/2024/06/07/redis/双写一致表达.jpg" alt="双写一致表达"><figcaption aria-hidden="true">双写一致表达</figcaption></figure><p>redis的持久化：</p><p>RDB redis数据备份文件， 内存数据存入磁盘 bgsave（主动） save 900 1save 300 10 60 10000 （redis.conf被动）</p><p>AOF追加文件，命令日志 执行重写效果</p><p>删除策略：惰性删除 （不管他，过期了就删除）</p><p>定期删除：检查，删除过期，一些key</p><p>2.分布式锁</p><p>setnx命令</p><p>SET lock value NX EX 10</p><p>DEL key</p><p>redisson实现的分布式锁-执行流程（可重入）</p><figure><img src="/2024/06/07/redis/redisson分布锁.jpg" alt="redisson分布锁"><figcaption aria-hidden="true">redisson分布锁</figcaption></figure><p>加锁设置过期时间等操作都是基于lua脚本完成</p><figure><img src="/2024/06/07/redis/redis集群回答.jpg" alt="edis集群回答"><figcaption aria-hidden="true">edis集群回答</figcaption></figure><p>redis集群方案：</p><p>主从复制</p><p>哨兵模式</p><p>分片集群</p><figure><img src="/2024/06/07/redis/分片集群.jpg" alt="分片集群"><figcaption aria-hidden="true">分片集群</figcaption></figure><p>16384个哈希槽，</p><figure><img src="/2024/06/07/redis/分片解答.jpg" alt="分片解答"><figcaption aria-hidden="true">分片解答</figcaption></figure><figure><img src="/2024/06/07/redis/单线程快速回答.jpg" alt="单线程快速回答"><figcaption aria-hidden="true">单线程快速回答</figcaption></figure><p>3.消息队列、延迟队列</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.缓存&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/2024/06/07/redis/缓存穿透.jpg&quot; alt=&quot;缓存穿透&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;缓存穿透&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figu</summary>
      
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>TCP UDP HTTP</title>
    <link href="http://suojifeng.xyz/2024/06/06/tcp-udp-http/"/>
    <id>http://suojifeng.xyz/2024/06/06/tcp-udp-http/</id>
    <published>2024-06-06T07:33:15.000Z</published>
    <updated>2024-08-07T08:44:13.043Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/06/06/tcp-udp-http/Blog\source_posts\TCP-UDP-HTTP\Untitled.png" alt="Untitled">三次握手，四次挥手</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/06/06/tcp-udp-http/Blog&#92;source_posts&#92;TCP-UDP-HTTP&#92;Untitled.png&quot; alt=&quot;Untitled&quot;&gt;三次握手，四次挥手&lt;/p&gt;
</summary>
      
    
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://suojifeng.xyz/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>不忘初心</title>
    <link href="http://suojifeng.xyz/2024/05/22/bu-wang-chu-xin/"/>
    <id>http://suojifeng.xyz/2024/05/22/bu-wang-chu-xin/</id>
    <published>2024-05-22T00:32:14.000Z</published>
    <updated>2024-05-22T12:55:11.253Z</updated>
    
    <content type="html"><![CDATA[<p>正是关键时刻，回顾过往，今年正好是大有可为的时候所以要抓住机会</p><p>晚上还是会想起之前的那些故事，难免会把自己带入，不是说还有多难忘，而是就像是一个标志性的事件，大概快有6年了，距离高三结束，希望今年会有好的结果，之前的教训一定要吸取。</p><p>发现晚上还是会想起以前的事情，估计是我太无趣了吧，还没有点新鲜的事情。</p><p>已经很久了，已经是2024年的4月份了，我的小论文实验已经感觉到了最后的关头，但是才是刚刚开始，但是我觉得还是创新点有点不够，但是时间已经到了这里，我必须要去做出抉择和努力，我的身体最近也开始有点不舒服，我觉得我需要开始去锻炼了，这正好是一个好的时机。</p><p>加强自己的意志力，这才刚刚开始高强度的学习，可不能就此倒下，加油重回自己的青春，抓紧时间去搞定这些内容，放上我最近喜欢听的歌曲，希望你们可以喜欢：隐形的翅膀</p><p>十年人间！</p><p>就是在这个慌乱不知所措的时候才是要去让自己的心静下来，去考虑自己到底需要什么，需要什么东西‘好像确实你缺爱吗，你自卑吗，你想要证明自己吗，你爱面子吗，你到底是个什么人我觉得你自己更清楚自己一点，所以我想知道未来会怎么样，我会怎样</p><p>不正是自己所做的决定在决定着未来的走向。在这个无法捉摸到的时候才是最难熬最需要坚持的地方，我坚信这是你需要努力，需要去做的事情，好像还是会很想看你的近况，我的近况反思，我最近好像抱怨的东西越来越多了，不知道会不会有人注意到呢，看头像看朋友圈那属实是屌丝不能再屌丝了</p><p>无数次回望那个瞬间，我都很难过，又不得不向前，这就是人生吧。</p><p>希望你看到这个会开心，我是无所谓了，被人遗忘被人忽视好像也就是自己的宿命。</p><figure><img src="/2024/05/22/bu-wang-chu-xin/wallhaven.jpg" alt="爱与自由"><figcaption aria-hidden="true">爱与自由</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;正是关键时刻，回顾过往，今年正好是大有可为的时候所以要抓住机会&lt;/p&gt;
&lt;p&gt;晚上还是会想起之前的那些故事，难免会把自己带入，不是说还有多难忘，而是就像是一个标志性的事件，大概快有6年了，距离高三结束，希望今年会有好的结果，之前的教训一定要吸取。&lt;/p&gt;
&lt;p&gt;发现晚上</summary>
      
    
    
    
    <category term="My Daily Life" scheme="http://suojifeng.xyz/categories/My-Daily-Life/"/>
    
    
    <category term="daily life" scheme="http://suojifeng.xyz/tags/daily-life/"/>
    
    <category term="CR" scheme="http://suojifeng.xyz/tags/CR/"/>
    
  </entry>
  
  <entry>
    <title>好久不见</title>
    <link href="http://suojifeng.xyz/2024/05/13/hao-jiu-bu-jian/"/>
    <id>http://suojifeng.xyz/2024/05/13/hao-jiu-bu-jian/</id>
    <published>2024-05-13T09:32:42.000Z</published>
    <updated>2024-05-20T09:10:59.270Z</updated>
    
    <content type="html"><![CDATA[<p>讲真好久不见</p><p>不知不觉已经5月份了，时间过得好快啊，日记倒是没有写多少，生活也好像没什么进步</p><p>论文难道就这样吗，但是确实好像不用什么创新的地方</p><p>时间匆匆如流水，好像已经5月15号了</p><p>本科生的进度也是需要加快了，两周时间吧</p><p>每天好像不知道我应该去做什么，看文献吧又感觉无知无趣。</p><p>真的是感觉静不下心来，我需要去好好的思考一下了，我应该怎么去完成我应该完成的任务，还是需要冷静，将自己放在一个好的位置。</p><p>加油，也是挺羡慕人家的一些</p><p>不忘初心，好像知道慎独才是需要去注意的，有什么坏的习惯但是一定要好好想想</p><p>我好像是好说话一点，喜欢为被人考虑，但是我总是忙忙碌碌获得坏的结果</p><p>我害怕结果是坏的，我无法迈出第一步，我无法让自己去做更高能量的事</p><p>马上就要6月份，是不是需要迈出那一步了</p><p>想或不想，做或不做都是一个需要考虑的问题，跟随自己的内心，做自己认为正确的事情</p><p>认真对人，认真做事。</p><p>思想不积极那就放手</p><p>不知道怎样才算放下。</p><p>那就让自己放空才知道自己最需要什么</p><p>才子词人，自是白衣卿相</p><figure><img src="/2024/05/13/hao-jiu-bu-jian/QQ图片20240427145429.gif" alt="QQ图片20240427145429"><figcaption aria-hidden="true">QQ图片20240427145429</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;讲真好久不见&lt;/p&gt;
&lt;p&gt;不知不觉已经5月份了，时间过得好快啊，日记倒是没有写多少，生活也好像没什么进步&lt;/p&gt;
&lt;p&gt;论文难道就这样吗，但是确实好像不用什么创新的地方&lt;/p&gt;
&lt;p&gt;时间匆匆如流水，好像已经5月15号了&lt;/p&gt;
&lt;p&gt;本科生的进度也是需要加快了，</summary>
      
    
    
    
    <category term="My Daily Life" scheme="http://suojifeng.xyz/categories/My-Daily-Life/"/>
    
    
    <category term="daily life" scheme="http://suojifeng.xyz/tags/daily-life/"/>
    
  </entry>
  
  <entry>
    <title>新的一年新的开始</title>
    <link href="http://suojifeng.xyz/2024/04/30/xin-de-yi-nian-xin-de-kai-shi/"/>
    <id>http://suojifeng.xyz/2024/04/30/xin-de-yi-nian-xin-de-kai-shi/</id>
    <published>2024-04-30T08:00:00.000Z</published>
    <updated>2024-05-13T09:34:15.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回首2023">回首2023</h1><p>​2024年到来，我终于想起这里还有我的博客，从我心血来潮建立到现在好像只有89月份在努力的每天记录，不得不说那两个月是我用心学习的两个月。</p><p>​本来的方向是做医疗知识图谱，但是现在又换了赛道，从之前的9月份一整个月都在做知识图谱，后来到了10月份和11月份，突然要转到遥感的方向，迷茫中。</p><p>​10月份探索遥感领域，首先是了解了一些基本的简单的概念，总体来说国庆放假之后就只剩下三周的时间了，从刚开始的找数据集，懵懵懂懂，到确定做时间序列相关的遥感又是一个大的进步，但是这之间又是迷迷糊糊，感觉像是没有找到合适的关键词</p><p>​ 在10月份末还是找到了有关于satellite image time series的方向，读了读很经典的文献就是CNN领域里的全卷积网络和timeCNN，还有经典的 TAE LTAE PAE像素编码的阶段。</p><p>​ 然后又看到了多模态和迁移学习的方向，这次是看到了transferlearning和知识蒸馏的部分，觉得找到了真正可以做的有实际意义的地方，这就是到了10月末11月初。</p><p>​或许是觉得多模态可以做，然后就看了不少的多模态的文章，这也是算是把这个遥感领域的多模态文章都看过了，主要是光谱和SAR雷达的融合</p><p>​11月初的那一周好像没怎么看论文，或者说看了但是没有看多少，看了一些经典的高光谱的文章，有一些转到视觉方面去了，还是及时止损，还是想要靠上去遥感，真是不该。</p><p>​然后的一周觉得视觉还有点希望，确实还有一点可以做的东西，在spectralFormer里面找到的关于光谱方面的灵感，就是多个波段绑定在一起输入。</p><p>​ 还是在多模态的大坑里面游泳，看了几篇文献在反复横跳。</p><p>​到了11月份的第三周，突然看向了时间序列预测，又是横跳的一周，感觉又是找到了多模态公开的代码和数据集又是感觉可以做的一周，看看经典的文献也就是PATIAS数据集</p><p>​ 终于死心对多模态做出了总结这样转到了时间序列11月份又过去了。</p><p>​到了12月份之后，我是直接想要用时间序列来解决遥感相关的问题，然后去期刊上面寻找timeseries的相关论文，看了几篇有了点思路但是没有复现，问题还是有点大，这第一周又过去了，看了文献就相当于扩展思路了，顺便在第二周找了找一些相关的数据集，下载了下载。</p><p>​ 准备使用transformer去看看有没有什么可以做的，就已经很不错了</p><p>​然后在第三周找了个可以复现的文章感觉还可以，然后就感觉过得很快干了些杂货就忙忙碌碌的到了最后一周。</p><p>​最后一周也是紧挨着元旦，也没有很大进展，唯一的进展就是我把之前的对比学习的多模态遥感的那篇论文给复现了出来，也算是给自己一个交代在2023年的末尾。</p><h1 id="展望2024">展望2024</h1><p>​ 接下来的一年准备在多元时间序列的分类上面做一些工作和学习，因为遥感也可以说是土地分类就是一个特殊的MTSC任务，所以是可以迁移的。认准了就开始干吧。</p><h1 id="五一前夕">五一前夕</h1><p>马上就要5月份了，但是好像还是没有进入状态，今年确实应该是十分重要的一年，需要去做出准备，好像有半个月都没有刷题了吧，不知道是不是忘了，但是呢</p><p>既然现在知道了，就应该去采取行动</p><p>我不知道我们作为一个硕士需要多大的创新才可以，但是我觉得这已经算是很可以的了，加油吧，主要是把剩下的实验和图都画完，我知道这是一个艰苦的工作，但是必须要完成，应该是在五一的期间完成的，这其实可以说是一个自我超越的时候，去完成应该完成的工作</p><p>生活不知如何让我刁难，我的运气好像也是不好，不知是否是露怯还是怎么样，我爱面子嘛，感觉不是我只是觉得生活不应让我太难过，希望生活对我好一点把。</p><p>放上一个我喜欢的诗词：</p><p>人生若只如初见</p><p>何事秋风悲画扇</p><p>等闲变却故人心</p><p>却道故人心易变</p><figure><img src="/2024/04/30/xin-de-yi-nian-xin-de-kai-shi/花花.jpg" alt="花花"><figcaption aria-hidden="true">花花</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回首2023&quot;&gt;回首2023&lt;/h1&gt;
&lt;p&gt;​
2024年到来，我终于想起这里还有我的博客，从我心血来潮建立到现在好像只有8
9月份在努力的每天记录，不得不说那两个月是我用心学习的两个月。&lt;/p&gt;
&lt;p&gt;​
本来的方向是做医疗知识图谱，但是现在又换了赛</summary>
      
    
    
    
    <category term="My Daily Life" scheme="http://suojifeng.xyz/categories/My-Daily-Life/"/>
    
    
    <category term="daily life" scheme="http://suojifeng.xyz/tags/daily-life/"/>
    
  </entry>
  
  <entry>
    <title>时序思考</title>
    <link href="http://suojifeng.xyz/2024/01/24/2024-shuo-shi/"/>
    <id>http://suojifeng.xyz/2024/01/24/2024-shuo-shi/</id>
    <published>2024-01-24T13:35:34.000Z</published>
    <updated>2024-02-28T13:13:07.426Z</updated>
    
    <content type="html"><![CDATA[<p>新的开始，目前发现一个好的方向那就是patch，我想在这方面下功夫做出我自己的代码</p><p>但是最近的工作感觉是有在这个方面，但是基本上都在长时序预测上面，在分类上面我觉得应该应该是有区别的</p><p>所以 我觉得通道独立这个是不太对的，我觉得需要是需要考虑channel上面的注意力。我觉得应该要这么做，在明天把这几篇有关于patch的文章看完之后，我就去想自己的创新点，首先要是在自己的数据集上调通，然后就在想其他方法的问题。</p><p>明天会更新一下一些相关的论文，有关于patch的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新的开始，目前发现一个好的方向那就是patch，我想在这方面下功夫做出我自己的代码&lt;/p&gt;
&lt;p&gt;但是最近的工作感觉是有在这个方面，但是基本上都在长时序预测上面，在分类上面我觉得应该应该是有区别的&lt;/p&gt;
&lt;p&gt;所以 我觉得通道独立这个是
不太对的，我觉得需要是需要考</summary>
      
    
    
    
    <category term="My Daily Life" scheme="http://suojifeng.xyz/categories/My-Daily-Life/"/>
    
    
    <category term="daliy life" scheme="http://suojifeng.xyz/tags/daliy-life/"/>
    
  </entry>
  
</feed>
